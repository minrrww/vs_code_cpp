# primer学习

## 第五章 语句

### 5.1 简单语句

- 表达式语句（expression statement）:执行表达式，并丢弃掉求值结果
  - 表达式语句比较普遍的是求值时附带其他效果，给变量赋新值或输出了结果
- 空语句（null statement）：空语句，语法上需要一条语句，但逻辑上不需要
  - 空语句在if,while条件后面可能完全改变程序员的初衷
- 复合语句（compound statement）：花括号括起来的语句或声明的序列，也叫块（block）
  - 块不以分号结束
  - 空块等价于空语句

```cpp
#include <iostream>
using namespace std;
int main()
{
    //1.表达式语句
    int ival = 0, sum = 0;
    ival + 5;             //没用的表达式语句
    cout << ival << endl; //有用的表达式语句
    //2.空语句
    //重复读入数据直至到达文件末尾或某次输入的值等于sought
    int s, sought = 0;
    while (cin >> s && s != sought)
        ; //空语句
    //3.复合语句（块）
    while (ival <= 10)
    {
        sum += ival; //把sum+ival的值赋给sum
        ++ival;      //给ival加1
    }
    cout << sum << " " << ival;
    return 0;
}
```

### 5.2 语句作用域

- 在if、switch、while和for语句的控制结构内定义的变量，其内部可见
  - 如果其他代码需要访问控制变量，则变量必须定义在语句的外部。

```cpp
#include <iostream>
#include <vector>
using namespace std;
int main()
{
    int get_num = 0;
    while (int i = get_num) //每次迭代时创建并初始化i
        cout << i << endl;
    //寻找第一个负值元素
    vector<int> v = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    auto beg = v.begin();
    while (beg != v.end() && *beg >= 0)
        ++beg;
    if (beg == v.end())
        cout << "v中每个元素都大于等与0" << endl;
    return 0;
}
/*v中每个元素都大于等于0*/
```

### 5.3 条件语句

#### 5.3.1 if语句（if statement）
- if语句：判断一个指定的条件是否为真，根据判断结果决定是否执行另外一条语句
  - if语句两种形式：一种含有else,另一种没有
- 嵌套if语句
- 悬垂else（dangling else）：c++规定else与离它最近的尚未匹配的if匹配

#### 5.3.2 switch语句（switch statement）

- switch语句：提供了一条便利的途径使得我们能够在若干固定选项中做出选择。
  - 如果switch(表达式)中的表达式与case标签的值匹配成功，
  - 程序从该标签之后第一条语句开始执行，
  - 直到达到了switch的结尾或者遇到一条break语句为止。
- break语句的作用是中断当前的控制流。
  - 在switch语句中，break将语句控制权转移到switch语句外面。
  - 有时，我们希望两个或更多值共享同一组操作，故意省略掉break语句。
  - 写漏break语句容易引发缺陷。
- case关键字和它对应的值一起被称为case标签（case label），
  - 必须是整型常量表达式，任何两个case标签值不能相同，
- default也是一种特殊的case标签。default:...break;
  - 表示程序默认情况，如果switch结构以一个空default标签作为结束，
  - 必须跟上一个空语句或空块
- switch内部的变量定义：若果有变量定义在跳过的case标签后，
  - 应该把变量定义在块内，确保后面的所有case标签都在变量的作用域之外。

```cpp
#include <iostream>
#include <vector>
using namespace std;
int main()
{
    //5.3.1
    const vector<string> scores = {"F", "D", "C", "B", "A", "A++"};
    unsigned int grade;
    string lettergrade;
    cin >> grade;
    //如果成绩不合格，不需要添加+或-
    if (grade < 60)
        cout << (lettergrade = scores[0]) << endl;
    else
    {
        lettergrade = scores[(grade - 50) / 10]; //获得字幕形式的成绩
        if (grade != 100)                        //只要成绩不是A++，就考虑+或-
            if (grade % 10 > 7)
                lettergrade += '+'; //末尾是8或9，添加一个+
            else if (grade % 10 < 3)
                lettergrade += '-'; //末尾是0,1或2，添加一个-
        cout << lettergrade << endl;
    }

    //5.3.2
    unsigned aCnt = 0, eCnt = 0, iCnt = 0, oCnt = 0, uCnt = 0;
    char ch;
    while (cin >> ch)
    {
        //如果ch是元音字母，将其对应的计数器值加1
        switch (ch)
        {
        case 'a':
            ++aCnt;
            break;
        case 'e':
            ++eCnt;
            break;
        case 'i':
            ++iCnt;
            break;
        case 'o':
            ++oCnt;
            break;
        case 'u':
            ++uCnt;
            break;
        default:
            break;
        }
    }
    cout << aCnt << " " << eCnt << " " << iCnt << " " << oCnt << " " << uCnt << endl;
    return 0;
}
```

//5.4 迭代语句
//迭代语句通常称为循环。
//5.4.1 while语句
/*1.只要条件为真，while语句（while statement）就重复地执行循环体。
  2.while的的条件部分可以是一个表达式或者一个带初始化的变量声明，
    条件本身或循环体设法 改变表达式的值，否则循环可能无法终止。
  3.当不确定到底要迭代多少次时，使用while循环比较合适。
*/
//5.4.2 传统的for语句
/*1.for语句的语法形式：for(init-statement;condition;expression)statement;
    init-statement必须是以下三中形式中的一种：声明语句、表达式语句或者空语句。
    expression负责修改init-statement初始化的变量，
    这个变量正式condition检查的对象。
  2.for语句头中的多重定义，init-statement可以定义多个对象，但只能有一条声明语句。
  3.省略for语句头的某些部分：可以省略任何一个或全部。
    省略init-statement，可以用空语句。
    省略condition，在循环体内必须有语句负责退出循环，否则就会一直循环下去。
    省略expression，这样的循环要求条件部分或循环体内必须改变迭代变量的值。*/
//5.4.3 范围for语句
/*1.C++11引入了一种更简单的for语句，这种语句可以遍历容器或其他序列的所有元素。
    范围for语句（range for statement）的语法形式：
    for(declaration:expression)statement
    1.expression表示一个序列，比如用花括号括起来的初始值列表、
      数组、vector、string等类型的对象，
      这些类型的共同特点是能返回迭代器begin和end成员。
    2.declaration定义一个变量，序列中每个元素都能转化成该变量的类型。
      如果需要对序列中的元素执行写操作，循环变量必须声明成引用类型。*/
//5.4.4 do while 语句
/*1.do while先执行循环体，再检查条件，不管条件如何，至少循环一次。
  2.do while语句的语法形式：do statement while(condition).
    condition不能为空，condition使用变量必须定义在循环体外。
    不能再循环体，和条件部分定义变量。*/
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    //5.4.1
    vector<int> v;
    //重复读入数据，直到达到文件末尾或者遇到其他输入问题
    for (int i; cin >> i; /*表达式为空*/)
        v.push_back(i);
    cin.clear(); //设置cin状态为0
    cin.sync();  //清除缓存区数据流
    //int i;
    /*while (cin >> i)
         v.push_back(i);*/
    //寻找第一个负值元素
    auto beg = v.begin();
    while (beg != v.end() && *beg >= 0)
        ++beg;
    if (beg == v.end())
        cout << "v中所有元素大于等于0" << endl;
    //5.4.2
    string s = "Hello,world!";
    //重复处理s中的字符直至我们处理完全部字符或者遇到一个表示空白的字符
    for (decltype(s.size()) index = 0; index != s.size() && !isspace(s[index]); ++index)
        cout << (s[index] = toupper(s[index])); //将当前字符改成大写形式
    cout << endl;

    for (decltype(v.size()) i = 0, sz = v.size(); i != sz; ++i)
        cout << v[i] << endl;

    beg = v.begin();
    for (/*空语句*/; beg != v.end() && *beg >= 0; ++beg)
        ; //什么也不做
    //5.4.3
    vector<int> iv = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    //范围变量必须是引用类型，这样才能对元素执行写操作
    for (auto &r : iv) //对于iv中的每一个元素
        cout << (r *= 2) << " ";
    cout << endl;
    for (auto beg = iv.begin(), end = iv.end(); beg != end; ++beg)
    {
        auto &r = *beg;          //r必须是引用类型，这样才能对元素执行写操作
        cout << (r *= 2) << " "; //对于iv中的每一个元素的值翻倍
    }
    cout << endl;
    //5.4.4
    //不断提示用户输入一对数，然后求和
    string rsp; //作为循环的条件，不能定义在do的内部
    do
    {
        cout << "please enter two values:" << endl;
        int val1 = 0, val2 = 0;
        cin >> val1 >> val2;
        cout << "The sum of " << val1 << " and " << val2
             << " = " << val1 + val2 << "\n\n"
             << "More?Enter yes or no: ";
        cin >> rsp;
    } while (!rsp.empty() && rsp[0] != 'n');
    return 0;
}
/*
23
56
89
98
65
32
^Z
v中所有元素大于等于0
HELLO,WORLD!
23
56
89
98
65
32
0 2 4 6 8 10 12 14 16 18
0 4 8 12 16 20 24 28 32 36
please enter two values:
23
65
The sum of 23 and 65 = 88

More?Enter yes or no:
2
please enter two values:
56
98
The sum of 56 and 98 = 154

More?Enter yes or no:
23
please enter two values:
65
56
The sum of 65 and 56 = 121

More?Enter yes or no:
n
*/

//5.5 跳转语句
//1.C++提供了4中跳转语句：break、continue、goto和return。
//5.5.1 break语句
/*1.break语句（break statement）负责终止离它最近的while、do while、for或switch语句，
    并从这些语句之后的第一条语句开始继续执行。
  2.break语句只能出现在迭代语句或者switch语句内部。*/
//5.5.2 continue语句
/*1.continue语句（continue statement）终止最近的循环中的当前迭代并立即开始下一次迭代。
  2.continue语句只能出现在for、while、do while循环的内部，
  或嵌套在此类循环里的语句或块内部。
  3.出现在嵌套循环中的continue语句仅作用于离它最近的循环，
  只有当switch语句嵌套在迭代语句内部时，才能在switch里使用continue。*/
//5.5.3 goto语句
//goto语句（goto statement）的作用是从goto语句无条件跳转到同一函数内的另一条语句。
//1.不要在程序中使用goto语句，因为它使得程序既难理解。
/*2.goto语句的语法形式：goto label;label是用于标识一条语句的标示符。
    带标签语句（labeled statement）是一种特殊的语句，在它之前有一个标示符以及一个冒号：
    end:return;
  3.和switch语句类似，goto语句不能将程序的控制权从变量的作用域之外
    转移到作用域之内。
  4.向后跳过一个已经执行的定义是合法的。
    跳回到变量定义之前意味着系统将销毁该变量，然后重新创建它。*/

#include <iostream>

using namespace std;

int main()
{
    //5.5.1
    string buf;
    while (cin >> buf && !buf.empty())
    {
        switch (buf[0])
        {
        case '-':
            //处理到第一个空白为止
            for (auto it = buf.begin() + 1; it != buf.end(); ++it)
            {
                if (*it == ' ')
                    break; //#1，离开for循环
                //...
            }
            //break #1将控制权转移到这里
            //剩余的'-'处理：
            break; //#2,离开switch语句
        case '+':; //...
        }          //结束switch
        //结束switch：break #2将控制权转移到这里
    } //结束while
    cin.clear();
    cin.sync();

    //5.5.2
    while (cin >> buf && !buf.empty())
    {
        ir(buf[0] != '_') continue; //接着读取下一个输入
        //程序执行过程到了这里？说明当前的输入是以下划线开始的；接着处理buf...
    }
    return 0;
}

//5.6 try语句块和异常处理
//C++语言中，异常处理包括：
/*1.throw表达式（throw expression），
    异常检测部分使用throw表达式来表示它遇到了无法处理的问题。
    我们说throw引发（raise）了异常。
  2.try语句块（try block），异常处理部分使用try语句块处理异常。
    try语句块以关键字try开始，并以一个或多个catch子句（catch clause）结束。
    try语句块中代码抛出的异常通常会被某个catch子句处理。
    catch也被称作异常处理代码（exception handler）。
  3.一套异常类（exception class），
    用于在throw表达式和相关catch子句之间传递异常的具体信息。*/
//5.6.1 throw 表达式
/*1.程序的异常检测部分使用throw表达式引发一个异常。
    throw表达式包含关键字throw和紧跟其后的一个表达式，
    其中表达式的类型就是抛出的异常类型。紧跟分号，构成语句*/
//5.6.2 try 语句块
/*1.try 语句块语法形式：try {program-statement}
    catch(exception-declaration){handler-statements}
    catch(exception-declaration){handler-statements}//...
    catch子语句包括三部分：关键字catch、括号内一个（可能未命名的）对象的声明
    （称作异常声明，exception declaration）以及一个块。
    当选中了某个catch子句处理异常之后，执行与之对应的块。
    catch一旦完成，程序跳到try语句块最快一个catch子句之后的那条语句继续执行。
    try语句块中的program-statements组成程序的正常逻辑，
    可以包括声明在内的任意c++语句。
    块内声明的变量快外无法访问，特别是catch子句内无法访问。*/
//5.6.3 标准异常
/*1.exception头文件定义类最普通的异常类exception。它只报告异常的发生，不提供任何额外信息。
  2.stdexcept头文件定义类几种常用异常类。
  3.new头文件定义类bad_alloc异常类型。
  4.type_info头文件定义类bad_cast异常类型。*/

/*1.表 5.1：<stdexcept>定义的异常类
  exception          最常见的问题
  runtime_error      只有在运行时才能检测出的问题
  range_error        运行时错误：生成的结果超出了有意义的值域范围
  overflow_error     运行时错误：计算上溢
  underflow_error    运行时错误：计算下溢
  logic_error        程序逻辑错误
  domain_error       逻辑错误：参数对应的结果值不存在
  invalid_argument   逻辑错误：无效参数
  length_error       逻辑错误：试图创建一个超出该类型最大长度的对象
  out_of_range       逻辑错误：使用一个超出有效范围的值*/
/*2.我们只能以默认初始化的方式初始化exception、bad_alloc和bad_cast对象，
    不允许为这些对象提供初始值。
    其他异常类型的行为恰好相反：
    应该使用string对象或者C风格字符串初始化这些类型的对象，
    但不允许使用默认初始化的方式，必须提供初始值，
    初始值含有错误相关信息。
  3.异常类型只定义了一个名为what的成员函数，该函数没有任何参数，
    返回值是一个指向C风格字符串的const char*。
    what函数返回的C风格字符串的内容与异常对象的类型有关。
    如果异常类型有一个字符串初始值，则what返回该字符串。
    对无初始值的异常类型来说，what返回类型的内容由编译器决定。*/

#include <iostream>
#include <stdexcept>
#include "SalesItem.h"
using namespace std;

int main()
{
    SalesItem item1, item2;
    //cin >> item1 >> item2;
    //首先检查item1和item2是否表示同一种书籍
    /*if (item1.sameIsbn(item2))
    {
        cout << item1 + item2 << endl;
        return 0; //表示成功
    }
    else
    {
        cerr << "Data must refer to same ISBN" << endl;
        return -1;//表示失败
    }*/
    while (cin >> item1 >> item2)
    {
        try
        {
            //首先检查两条数据是否关于同一种书籍的
            if (!item1.sameIsbn(item2))
                throw runtime_error("Data must refer to same ISBN");
            //如果程序执行到这里，表示两个ISBN是相同的
            cout << item1 + item2 << endl;
            //执行添加两个SalesItem对象的代码
            //如果添加失败，代码抛出一个runtime_error异常
        }
        catch (runtime_error err)
        {
            //提醒用户两个ISBN必须一致，询问是否重新输入
            cout << err.what()
                 << "\nTry Again? Enter y or n" << endl;
            char c;
            if (!(cin >> c) || (c == 'n'))
                break; //跳出while循环
        }
    }
    return 0;
}
