#**primer学习笔记**

##*第一章 开始*
###1.2 iostream库

| 库       | 类型           | 对象                          |
| -------- | -------------- | ----------------------------- |
|          | istream 输入流 | cin 标准输入                  |
|          |                | cout 标准输出对象             |
| iostream | ostream 输出流 | cerr 输出警告和错误信息       |
|          |                | clog 输出程序运行时的一般信息 |

<< 输出运算符
ostream类型的对象<<右值
将右值写入ostream类型的对象中，返回ostream类型的对象作为计算结果

endl操纵符 结束当前行，并将设备关联的缓冲区中的内容刷到设备中

std 命名空间 cout endl cin等对象是定义在命名空间std中的
:: 作用域运算符

\>> 输入运算符
istream类型的对象>>右值
将读取的值存入右值，写入istream类型的对象中，并返回istream类型的对象作为计算结果

//example-1.2-.cpp
#include <iostream> //#include 指令:告诉编译器，需要用iostream库
/*
 *简单主函数：
 *读取两个数，求它们的和
 */
int main()
{
    //提示用户输入两个数
    std::cout << "Enter two numbers:" << std::endl;
    int v1 = 0, v2 = 0;   //保存我们读入的输入数据的变量
    std::cin >> v1 >> v2; //读取输入数据
    std::cout << "The sum of " << v1 << " and " << v2
              << " is " << v1 + v2 << std::endl;
    return 0;
}
/*
 *Enter two numbers:
 *27
 *35
 *The sum of 27 and 35 is 62
 */

1.4 控制流
1.4.1 while语句
while (condition) statement
检测condition条件，为真时执行statement，为假时停止。
condition条件为一个真或假的表达式。

//example-1.4.1-.cpp
#include <iostream>
using namespace std;
int main()
{
    int sum = 0, val = 1;
    //只要val的值小于等于10，while循环就会持续执行
    while (val <= 10)
    {
        sum += val; //将sum+val赋值给sum
        ++val;      //将val+1赋值给val
    }
    cout << "Sum of 1 to 10 inclusive is "
         << sum << endl;
    return 0;
}
/*
 *Sum of 1 to 10 inclusive is 55
 */

 1.4.2 for 语句
 //example-1.4.2-.cpp
#include <iostream>
using namespace std;
int main()
{
    int sum = 0;
    //从1加到10
    for (int val = 1; val <= 10; ++val)
    {
        sum += val; //将sum+val赋值给sum
    }
    cout << "Sum of 1 to 10 inclusive is "
         << sum << endl;
    return 0;
}
/*
 *Sum of 1 to 10 inclusive is 55
 */

1.4.3 读取数量不定的输入数据
//example-1.4.1-.cpp
#include <iostream>
using namespace std;
int main()
{
    int sum = 0, value = 0;
    //读取数据直到遇到cin无效，计算所有读入的值得和
    //windows系统文件结束符ctrl+z，enter;linux系统文件结束符ctrl+d
    //返回的cin对象无效指遇到文件结束符（end-of-file）或无效输入
    while (cin >> value)
        sum += value; //将sum+val赋值给sum
    cout << "Sum is: "
         << sum << endl;
    return 0;
}
/*
 *23
 *32
 *^Z
 *Sum is: 55
 */

语法错误（syntax error）
类型错误（type error）
声明错误（declaration error）

1.4.4 if 语句
//example-1.4.4-.cpp
#include <iostream>
using namespace std;
int main()
{
    //currVal是我们正在统计的数；我们将读入的新值存入val
    int currVal = 0, val = 0;
    //读取第一个数，并确保实有数据可以处理
    if (cin >> currVal)
    {
        int cnt = 1; //保存我们正在处理的当前值的个数
        while (cin >> val)
        {                       //读取剩余的数
            if (val == currVal) //如果值相同
                ++cnt;          //cnt自加1
            else
            { //否则，打印前一个值得个数
                cout << currVal << " occurs "
                     << cnt << " times" << endl;
                currVal = val; //记住新值
                cnt = 1;       //重置计数器
            }
        } //while循环在这里结束
        //记住打印文件中最后一个值得个数
        cout << currVal << " occurs "
             << cnt << " times" << endl;
    } //最外层的if语句在这里结束
    return 0;
}
/*
 *42 42 42 42 42 55 55 62 100 100 100 42^Z
 *42 occurs 5 times
 *55 occurs 2 times
 *62 occurs 1 times
 *100 occurs 3 times
 *42 occurs 1 times
 */

 1.5.1 SalesItem类

//example-1.5.1-.cpp
#include <iostream>
#include "SalesItem.h"
using namespace std;
int main()
{
    SalesItem book1; //声明变量，并调用无参数构造函数
    //读入ISBN号，售出的册数以及销售价格
    cin >> book1;
    SalesItem book2 = SalesItem(); //调用无参构造函数
    //读入ISBN号，售出的册数以及销售价格
    cin >> book2;
    SalesItem book3("0-201-70353-X");       //调用一个参数构造函数
    SalesItem book4("0-201-70353-X", 2);    //调用二个参数构造函数
    SalesItem book5("0-201-70353-X", 2, 3); //调用三个参数构造函数
    SalesItem book6 = SalesItem(cin);       //读入ISBN号，售出的册数以及销售价格
    SalesItem book7();                      //声明函数，而不是调用无参构造函数
    //写出ISBN号，售出的册数、总销售额以及平均价格
    cout << book6 + book1 + book2 + book3 + book4 + book5 + book7() << endl;
    return 0;
}
SalesItem book7()
{
    SalesItem book;
    cin >> book;
    return book;
}
/*
 *0-201-70353-X 3 3
 *0-201-70353-X 4 3
 *0-202-70353-X 5 3
 *0-201-70353-X 6 3
 *0-202-70353-X   22      60      2.72727
 */
//共售出22 本书，销售额60元，均价2.72727元

//SalesItem.h
#ifndef SALESITEM_H
#define SALESITEM_H
#include <iostream>
#include <string>
using namespace std;
class SalesItem
{
private:                //私有数据成员
    string isbn;        //书的ISBN号
    unsigned unitsSold; //售出数量（本）
    double revenue;     //销售总价
public:                 //外部接口
                        //带默认值的构造函数，相当于4次重载:无参数，1参数，2参数，3参数
    SalesItem(string isbn = "", unsigned unitsSold = 0, double price = 0.0)
        : isbn(isbn), unitsSold(unitsSold)
    {
        revenue = price * unitsSold;
    }
    SalesItem(istream &is) { is >> *this; }                             //重载构造函数，用构造函数读入输入流
    SalesItem &operator+=(const SalesItem &s);                          //重载+=运算符
    friend istream &operator>>(istream &in, SalesItem &s);              //用友元函数重载>>运算符
    friend ostream &operator<<(ostream &is, const SalesItem &s);        //用友元函数重载<<运算符
    friend bool operator==(const SalesItem &lhs, const SalesItem &rhs); //友元函数可以访问私有数据成员
    double avgPrice() const                                             //求平均售价
    {
        if (unitsSold) //如果数量不为0，返回平均值
            return revenue / unitsSold;
        else //如果数量为0,返回0.0
            return 0.0;
    }
    bool sameIsbn(const SalesItem &s) //比较ISBN是否相等
    {
        return isbn == s.isbn;
    }
};
SalesItem operator+(const SalesItem &lhs, const SalesItem &rhs); //声明重载+运算符
istream &operator>>(istream &in, SalesItem &s)                   //实现重载>>运算符，返回左值，返回类型使用引用
{
    double price = 0;                     //定义单价
    in >> s.isbn >> s.unitsSold >> price; //输入流ISBN，数量，单价
    if (in)                               //如果输入流有效，计算总价
        s.revenue = s.unitsSold * price;
    else //否则，将无参数构造函数赋值给s
        s = SalesItem();
    return in; //返回左值
}

ostream &operator<<(ostream &is, const SalesItem &s) //实现重载<<运算符，返回左值，返回类型使用引用
{
    is << s.isbn << "\t" << s.unitsSold << "\t" << s.revenue << "\t" << s.avgPrice(); //输出几个值
    return is;                                                                        //返回左值
}

bool operator==(const SalesItem &lhs, const SalesItem &rhs) //声明并实现重载==运算符
{                                                           //全等为真，否则为假
    return lhs.unitsSold == rhs.unitsSold && lhs.isbn == rhs.isbn && lhs.revenue == rhs.revenue;
}

bool operator!=(const SalesItem &lhs, const SalesItem &rhs) //声明并实现重载!=运算符
{
    return !(lhs == rhs); //利用重载的==运算符
}

SalesItem &SalesItem::operator+=(const SalesItem &s) //实现重载+=运算符
{
    unitsSold += s.unitsSold;
    revenue += s.revenue;
    return *this; //返回左值
}

SalesItem operator+(const SalesItem &lhs, const SalesItem &rhs) //实现重载+运算符
{
    SalesItem ret(lhs); //利用构造函数创建对象
    return ret += rhs;  //调用重载的+=运算符
}
#endif


1.5.2 初识成员函数

//example-1.5.2-.cpp
#include <iostream>
#include "SalesItem.h"
using namespace std;
int main()
{
    SalesItem book1, book2; //声明变量，并调用无参数构造函数
    //读入ISBN号，售出的册数以及销售价格
    cin >> book1 >> book2;
    //检查是否是相同书籍
    if (book1.sameIsbn(book2)) //调用samIsbn函数
    {
        cout << book1 + book2 << endl;
        return 0; //表示成功
    }
    else
    {
        cerr << "Data must refer to same ISBN" << endl;
        return -1; //表示失败
    }
}
/*失败
 *0-201-70353-X 4 3
 *0-203-70353-X 5 3
 *Data must refer to same ISBN
*/
/*成功
 *0-201-70353-X 3 3
 *0-201-70353-X 4 3
 *0-201-70353-X   7       21      3
 */

1.6 书店程序
//example-1.6-.cpp
#include <iostream>
#include "SalesItem.h"
using namespace std;
int main()
{
    SalesItem total; //保存下一条交易记录点变量
    //读入第一条交易记录，并确保有数据可以处理
    if (cin >> total)
    {
        SalesItem trans; //保存和的变量
        //读入并处理剩余交易记录
        while (cin >> trans)
        {
            //如果我们扔在处理相同的书
            if (total.sameIsbn(trans))
                total += trans; //更新总销售额
            else
            {
                //打印前一本书的结果
                cout << total << endl;
                total = trans; //total现在表示下一本书的销售额
            }
        }
        cout << total << endl; //打印最后一本书的结果
    }
    else
    {
        //没有输入！警告读者
        cerr << "No data?!" << endl;
        return -1; //表示失败
    }
    return 0;
}
/*成功
0-201-70353-X 3 3
0-201-70353-X 4 3
0-201-70353-X 6 3
0-203-70353-X 5 3
0-201-70353-X   13      39      3
0-203-70353-X 4 3
0-203-70353-X 3 3
0-207-70353-X 7 3
0-203-70353-X   12      36      3
0-207-70353-X 4 3
0-207-70353-X 3 3
^Z
0-207-70353-X   14      42      3
 */
/*失败
0-207-70353-X a 3
No data?!
 */
