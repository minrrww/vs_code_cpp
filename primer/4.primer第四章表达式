第四章 表达式
表达式由一个后多个运算对象（operand）组成，对表达式求值将得到一个结果（result）
字面值和变量是最简单的表达式（expression）
把运算符（operator）和一个或多个运算对象组合起来可以生成较复杂的表达式

4.1.1 基本概念
一元运算符（unary operator）和二元运算符（binary operator）

组合运算符和运算对象
对于多个运算符的复杂表达式理解它的含义：
1.运算符的优先级（percedence）、结合律（associativity）
2.运算对象的求值顺序（order of evaluaion）

运算对象类型转换
运算对象类型不同，先转换为同一类型
小整数类型bool、char、short通常被提升（promoted）成较大的整数类型int

重载运算符
c++定义的运算符用于内置类型和复合类型的运算符
用户可以对已存在的运算符赋予另外一层含义，称为重载运算符
重载运算符时，包括一年算对象的类型和返回值的类型
但运算对象的个数、运算符的优先级和结合律都是无法改变的

左值和右值
c++d的表达式要么是右值（rvalue，读“are-value”），要么是左值（lvalue，读着“ell-value”）
C++中，左值表达式的求值结果是一个对象或者一个函数。
常量对象为代表的某些左值实际上不能作为赋值语句左侧运算对象的
某些表达式的求值结果是对象，但它们是右值而非左值
归纳：当一个对象被用作右值的时候，用的是对象的值（内容）；
      当对象被用作左值的时候，用的是对象的身份（在内存中的位置）
      右值可用用左值取代，但用的事左值的内容
      左值不能用右值取代

      赋值运算符需要一个（非常量）左值作为其左侧运算对象，得到的结果也任然是一个左值
      取地址符作用与一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值
      内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值
      内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得的结果也是左值

      decltype作用的表达式求值结果是左值，得到一个引用类型

      int *p;
      decltype(*p) 结果是int&
      decltype(&p) 结果是int **

      4.1.2 优先级与结合律
      复合表达式（compound expression）是指含有两个或多个运算符的表达式
      括号无视优先级和结合律

      4.1.3 求值顺序

      int i=f1()*f2();//f1()与f2()没有顺序，如果其中一个表达式修改了同一对象，将会引发未定义的行为

      int i = 0;
      cout << i << " " << ++i << endl;//先执行i还是先执行++i未定义，有的编译器会出错


有4种运算符明确规定了运算对象的求值顺序：
逻辑与（&&）运算符：先求左侧运算对象的值，只有当左侧运算对象的值为真才继续求右侧运算对象的值
逻辑或（||）运算符、条件（?:）运算符、逗号（,)运算符

求值顺序、优先级、结合律
运算对象的求值顺序与优先级和结合律无关
只要不改变同意对象的状态，也不执行IO任务，运算对象调用顺序不受限制
 4.2 算术运算符

 算术运算符（左结合律：优先级相同时从左向右的顺序进行组合）
 运算符       功能               用法
 +            一元正号           + expr
 -            一元负号           - expr

 *            乘法               expr * expr
 /            除法               expr / expr
 %            求余               expr % expr

 +            加法               expr + expr
 -            减法               expr - expr

 一元正号运算符、加法运算符、减法运算符都能作用于指针
 一元负号运算符对运算对象取负后，返回其（提升后的）副本
    int j = 1024;
    int k = -j; //k是-1024
    bool b = true;
    bool b2 = -b; //b2是1
    cout << k << " " << b2 << endl;

    整数相除商是整数，一律向0取整，及直接切除小数部分
    取余运算：如果m和n是整数且n非0，则表达式(m/n)*n+m%n==m
    除-m导致溢出的特殊情况，其他时候：
    (-m)/n==m/(-n)==-(m/n)
    m%(-n)==m%n,(-m)%n==-(m%n)

    4.3 逻辑与关系运算符
    逻辑运算符和关系运算符
    结合律     运算符    功能            用法
    右         !         逻辑非          !expr

    左         <         小于            expr < expr
    左         <=        小于等于        expr <= expr
    左         >         大于            expr > expr
    左         >=        大于等于        expr >= expr

    左         ==        相等            expr == expr
    左         !=        不相等          expr != expr

    左         &&        逻辑与          expr && expr

    右         ||        逻辑或          expr || expr

逻辑与和逻辑或的求值策略为短路求值（short-circuit evaluation）
逻辑与，当且仅当左侧运算符对象为真时，才对右侧运算符对象求值
逻辑或，当且仅当左侧运算符对象为假时，才对右侧运算符对象求值

逻辑非运算符，将运算对象的值取反后返回

关系运算符
if(i<j<k);//先把i和j用<运算符计算，返回的结果再和k用<计算，返回其结果
if(i<j&&j<k);//当i小于j并且j小于k时条件为真


相等性测试与布尔字面值
if(val){/*……*/}//如果val是任意非0值，条件为真
if(!val){/*……*/}//如果val是0，条件为真
if(val==true){/*……*/}//只有val等于1，条件为真
if(val==1){/*……*/}//如果val不是bool值，可以这样写
进行比较运算时除非比较的对象是布尔类型，
否则不要使用布尔字面值true和false作为运算对象


赋值运算符
赋值运算符的左侧运算对象必须是一个可以修改的左值
int i=0,j=0,k=0;//初始化而非赋值
const int ci=i;//初始化而非赋值
//1024=k;//错误，字面值是右值
//i+j=k;//错误，算术表达式是右值
//ci=k;//错误，ci是常量(不可修改)左值

赋值运算的结果是左侧运算对象，类型是左侧运算对象的类型
如果左右运算对象类型不同，右侧运算对象将转换成左侧运算对象的类型
k=0;//结果：类型是int,值是0
k=3.14159;//结果：类型是int ，值是3

c++11新标准允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象
//k={3.14};//错误：窄化转换
vector<int> vi;//初始值为空
vi = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};//vi含有10个元素，值0-9

赋值运算满足右结合律
int ival, jval;
ival = jval = 0;//正确都被赋值为0
//复制运算满足右结合律，把0赋值给jval，然后其运算结果赋值给ival

赋值运算优先级较低

切勿混淆相等运算符和赋值运算符

复合赋值运算符
使用复合赋值运算符只求值一次，使用普通的运算符则求值两次
#include <iostream>
#include <vector>
using namespace std;
class peaple
{
private:
public:
    void print()
    {
        cout << "print()" << endl;
    }
};
int get_value()
{
    int val;
    cin >> val;
    return val;
}
int main()
{
    int i = 0;
    cout << i << " " << ++i << endl; //先执行i还是先执行++i未定义，有的编译器会出错
    int j = 1024;
    int k = -j; //k是-1024
    bool b = true;
    bool b2 = -b; //b2是1
    cout << k << " " << b2 << endl;
    vector<string> str = {"Hello",
                          ",",
                          "My",
                          "name",
                          "is",
                          "Hanmeimei.",
                          "",
                          "Are",
                          "you?"};
    //s是对常量的引用；元素既没有被拷贝也不会改变
    for (const auto &s : str) //对于str的每一个元素
    {
        cout << s; //输出当前元素
        //遇到空字符或者以句号结束的字符串进行换行
        if (s.empty() || s[s.size() - 1] == '.')
            cout << endl;
        else
            cout << " "; //否则用空字符隔开
    }
    cout << endl;

    //int k = 0;
    //k = {3.14};//错误：窄化转换
    vector<int> vi;                      //初始值为空
    vi = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; //vi含有10个元素，值0-9

    int ival, jval;
    ival = jval = 0; //正确都被赋值为0
    //复制运算满足右结合律，把0赋值给jval，然后其运算结果赋值给ival
    int *pval; //pval是int *类型
    //ival = pval = 0; //错误，pval无法转换成int类型
    string s1, s2;
    s1 = s2 = "OK"; //字符串字面值转换成string对象
    peaple *p = 0;
    p->print();

    int g = get_value(); //得到第一个值
    while (g != 42)
    {
        //其他处理
        cout << g << endl;
        g = get_value(); //得到其他值
    }

    int h;
    //更好的写法：条件部分表达得更加清晰
    while ((h = get_value()) != 42)
    { //其他处理……
        cout << h << endl;
    }
    return 0;
}


4.5 递增递减运算符
前置 ++i,--i
后置 i++,i--
    int i = 0, j;
    j = ++i; //j=i=i+1;j=1,i=1;
    cout << i << " " << j << endl;
    j = i++; //j=i=1,i=i+1;j=1,i=2
    cout << i << " " << j << endl;
    i = 0;
    j = i++; //j=i=0,i=i+1;j=0,i=1
    cout << i << " " << j << endl;
    j = ++i; //j=i=i+1;j=2,i=2;
    cout << i << " " << j << endl;
建议养成使用前置版本的习惯

在一条语句中混用解引用和递增运算符
vector<int> v = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    auto pbeg = v.begin();
    //输出元素直至遇到第一个负值为止
    while (pbeg != v.end() && *pbeg >= 0)
        //后置递增优先级高于解引用，相当于*pbeg;++pbeg;
        cout << *pbeg++ << endl; //输出当前值并将pbeg向前移动一个元素

运算对象可按任意顺序求值
    string s = "welcome to China.";
    for (auto it = s.begin(); it != s.end() && !isspace(*it); ++it)
    {
        *it = toupper(*it);
        cout << *it;
    }
    cout << endl;
    auto beg = s.begin();
    while (beg != s.end() && !isspace(*beg))
    {
        *beg = toupper(*beg);//*beg = toupper(*beg++)未定义行为
        cout << *beg;
        beg += 1;
    }
    cout << endl;



//4.6 成员访问运算符
#include <iostream>
using namespace std;
int main()
{
    string s1 = "a string", *p = &s1;
    auto n = s1.size(); //运行string对象s1的size成员
    //因为解引用运算符的优先级低于点运算符，所以执行解引用运算的子表达式两端必须加上括号
    //*p.size();//错误p是指针，没有size()成员
    n = (*p).size(); //运行p所指对象的size成员
    cout << n << endl;
    n = p->size();   //等价于(*p).size()
    cout << n << endl;
    return 0;
    //箭头运算符作用于一个指针类型的运算对象，结果是一个左值
    //点运算符如果成员所属对象是左值，那么结果是左值；反之，如果成员所属的对象是右值，那么结果是右值
}
/*
8
8
*/

//4.7 条件运算符
/*1.当条件运算符的两个表达式都是左值或者都能转换成同一种左值类型时，
    运算结果是左值；否则运算结果是右值。*/
/*2.允许条件运算符的内部嵌套另外一个条件运算符。*/
/*3.条件运算符满足右结合律。*/
/*4.条件运算符优先级非常低，被嵌套时通常加括号。*/
#include <iostream>
#include <string>
using namespace std;
struct student
{
    string name;
    string num;
    unsigned grade;
};
int main()
{
    student s1 = {"Lilei", "20052958", 91};
    student s2 = {"Hanmeimei", "20052961", 59};
    //嵌套条件运算符
    cout << ((s1.grade > 90)   ? "hign pass"s
             : (s1.grade < 60) ? "fail": "pass");
    cout << endl;
    //在输出表达式中食用条件运算符
    cout << ((s2.grade < 60) ? "fail" : "pass");
    cout << endl;
    cout << (s2.grade < 60) ? "fail" : "pass";
    cout << endl;
    //cout << s2.grade < 60 ? "fail" : "pass";//错误
    return 0;
}
/*
hign pass
fail
1
*/

//4.8 位运算符
/*1.位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。*/
/*2.一种名为bitset的标准库类型可以表示任意大小的二进制集合。*/
/*3.表4.3：位运算符（左结合律）
运算符      功能      用法
~           位求反    expr

<<          左移      expr1 << expr2
>>          右移      expr1 >> expr2

&           位与      expr & expr

^           位异或    expr ^ expr

|           位或      expr | expr
*/
/*4.小整型会被自动提升成较大的整数类型。*/
/*5.运算对象可以带符号，如果是负数，如何处理符号位依赖机器。
    此时左位移操作会改变符号位的值，是一种未定义的行为。
    建议仅将位运算用于处理无符号类型。*/
//6.左移运算符<<在右侧插入值为0的二进制位，左侧提升位补符号位
//7.右移运算符>>无符号左侧插入0,有符号，左侧插入符号位
/*8.&对应位置都是1，则结果是1，否则是0；
    |对应位置至少一个是1,则结果是1，否则是0；
    ^对应位置有且只有一个为1，则运算结果是1，否则是0。*/
//9.移位运算符（又叫IO运算符）满足左结合律，比算术运算符低，比关系运算符高
#include <iostream>
#include <bitset>
#include <typeinfo>
#include <cmath>
using namespace std;
int main()
{
    unsigned char bits = 0233;
    //输出char类型的对象bits的二进制，占8位
    cout << bitset<sizeof(decltype(bits)) * 8>(bits) << endl;
    //输出bits<<8的二进制，自动提升为32位
    cout << bitset<sizeof(decltype(bits << 8)) * 8>(bits << 8) << endl;
    cout << bitset<sizeof(decltype(bits << 31)) * 8>(bits << 31) << endl;
    cout << bitset<sizeof(decltype(bits >> 3)) * 8>(bits >> 3) << endl;
    short s = -0233;
    /*原码:0b1000000010011011-->
      反码:0b1111111101100100-->
      补码:0b1111111101100101*/
    cout << bitset<sizeof(decltype(s)) * 8>(s) << endl;
    /*原码: 10000000000000001001101100000000-->
      反码：11111111111111110110010011111111-->
      补码：11111111111111110110010100000000*/
    //负数左位移,右侧插入0补齐，左侧插入符号位
    cout << bitset<sizeof(decltype(s << 8)) * 8>(s << 8) << endl;
    //左移8位，与乘以2的8次方值相同，类型不同
    cout << bitset<sizeof(s * int(pow(2, 8))) * 8>(s * int(pow(2, 8))) << endl;
    //求反运算符
    cout << bitset<sizeof(~bits) * 8>(~bits) << endl;
    //位与，位或，位异或运算符
    unsigned char b1 = 0145, b2 = 0257;
    cout << bitset<sizeof(decltype(b1 & b2)) * 8>(b1 & b2) << endl;
    cout << bitset<sizeof(decltype(b1 | b2)) * 8>(b1 | b2) << endl;
    cout << bitset<sizeof(decltype(b1 ^ b2)) * 8>(b1 ^ b2) << endl;

    unsigned long quiz1 = 0; //把值当位的集合
    quiz1 |= 1UL << 27;      //第27位改为1
    cout << bitset<sizeof(quiz1) * 8>(quiz1) << endl;
    quiz1 &= ~(1UL << 27); //第27位改为0
    cout << bitset<sizeof(quiz1) * 8>(quiz1) << endl;
    bool status = quiz1 & (1UL << 27); //第27位是否是1；
    cout << status << endl;

    return 0;
}
/*
10011011
00000000000000001001101100000000
10000000000000000000000000000000
00000000000000000000000000010011
1111111101100101
11111111111111110110010100000000
11111111111111110110010100000000
11111111111111111111111101100100
00000000000000000000000000100101
00000000000000000000000011101111
00000000000000000000000011001010
00001000000000000000000000000000
00000000000000000000000000000000
0
*/

//4.9 sizeof运算符
//1.sizeof运算符返回一条表达式或一个类型所占的字节数。
//2.sizeof运算符满足右结合律，所得值是一个size_t类型的常量表达式。
//3.sizeof与*运算符优先级相同，满足右结合律。
/*4.sizeof运算符不会实际求运算对象的值，
    运算对象可以是无效指针或未赋值的对象，
    也可以通过作用域运算符来获取类成员的大小。*/
//5.运算结果部分地依赖其作用的类型。
#include <iostream>
//#include <typeinfo>
using namespace std;
struct student
{
    string name;
    string num;
    unsigned grade;
};
int main()
{
    student s1 = {"Lilei", "20082958", 99}, *p, &r = s1;
    int i[5];
    cout << sizeof(student) << endl;              //存储结构体的对象所占的空间大小
    cout << sizeof s1 << endl;                    //s1的类型的大小，与sizeof(student) 相同
    cout << sizeof p << endl;                     //1.指针类型，结果是指针所占空间的大小
    cout << sizeof *p << endl;                    //2.解引用，得到p所指对象类型的大小，与sizeof(student) 相同
    cout << sizeof s1.name << endl;               //3.成员类型的大小
    cout << sizeof student::grade << endl;        //另一种获得成员类型大小的方法
    cout << sizeof(char) << endl;                 //4.char或类型为char的表达式，sizeof运算结果是1
    cout << sizeof r << endl;                     //5.引用类型，结果是引用对象所占空间大小
    cout << sizeof i << endl;                     //6.数组类型，结果是所有元素大小之和
    constexpr size_t sz = sizeof(i) / sizeof(*i); //数组占用空间大小与单个元素占用空间大小之商
    cout << sz << endl;
    int arr[sz];                    //sizeof返回的是常量表达式，所以可以用sizeof的结果声明数组的纬度
    cout << sizeof(string) << endl; //7.string类型，只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间
    return 0;
}
/*
72
72
8
72
32
4
1
72
20
5
32
*/

//4.10 逗号运算符
//1.逗号运算符（comma operator)含有两个运算对象，按照从左至右的顺序依次求值。
//2.逗号运算符规定了求值顺序，先求左侧表达式值，将结果丢弃。
//3.求值结果是右侧表达式的值，如果右侧是左值，结果就是左值。
//4.逗号运算符常被用在for循环中。
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<int> ivec = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    vector<int>::size_type cnt = ivec.size();
    //将把从size到1的值赋给ivec的元素
    for (vector<int>::size_type ix = 0; ix != ivec.size(); ++ix, --cnt)
        cout << (ivec[ix] = cnt) << " ";
    cout << endl;
    return 0;
}
/*
10 9 8 7 6 5 4 3 2 1
*/

//4.11 类型转换
//1.如果两种类型可以相互转换（conversion），那么它们是相互关联的。
//2.如果运算的对象类型不同，根据类型转换规则将运算对象类型统一后，在求值。
//3.无需程序员介入的，称作隐式转换（implicit conversion）。
//4.算术类型之间的隐式转换被设计得尽可能避免损失精度。
/*5.发生隐式转换的情形：
  1.在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。
  2.在条件中，非布尔值转换成布尔类型。
  3.在初始化过程中，初始值转换成变量的类型；
    在赋值语句中，右侧运算对象转换成左侧运算对象的类型。
  4.函数调用时也会发生类型转换*/

//4.11.1 算术转换（arithmetic conversion）
/*1.整型提升（integral promotion）
    1.小整数类型转换策成较大的整数类型
    bool、char、signed char、unsigned char、short和unsigned short等类型来说，
    只要它们所有可能的值都能存在int里，就会被提升成int类型；
    否则，提升成unsigned int类型。
    2.较大的char类型（wchar_t、char16_t、char32_t）提升成int、unsigned int、
    long、unsigned long、long long和unsigned long lomg中最小的一种类型*/
/*2.无符号类型的运算对象
    1.整数提升，提升后都是无符号或都是带符号的，小类型转换成大类型。
    2.提升后一个带符号，一个无符号，无符号类型不小于带符号类型*，
      带符号类型转换成无符号类型。
    3.带符号类型大于无符号类型，如果无符号类型所有值都能存在带符号类型中，
      无符号类型转换成带符号类型。
    4.如果不能，带符号类型转换成无符号类型。*/

//4.11.2 其他隐式类型转换
/*1.数组转换成指针：
    1.大多数表达式中，数组自动转换成指向数组首元素的指针。
    2.作为decltype的参数，&、sizeof及typeid等运算符的对象时，不发生转换。
    3.用引用来初始化数组，转换也不会发生。
    4.表达式中使用函数类型时会发生类似的指针转换。*/
/*2.指针的转换：
    0或者字面值nullptr转换成任意指针;
    指向任意非常量的指针能转换成void*;
    指向任意对象的指针能转换成const void*;
    在有继承关系的类型间还有另一种指针转换的方式。*/
/*3.转换成布尔类型
    指针或算术类型值为0，转换成false；否则转换成true。*/
/*4.转换成常量
    允许将指向非常量类型的指针转换成指向相应的常量类型的指针，对引用也是这样。
    相反，则不行。*/
/*5.类类型定义的转换
    类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换*/
//4.11.3 显式转换
//1.强制类型转换（cast），这种方法本质上是非常危险的，尽量避免强制类型转换。
/*2.命名的强制类型转换：cast-name<type>(expession)。
    1.static_cast 只要不包含底层const,都可以使用；
    对编译器无法执行的类型转换也非常有用。
    2.const_cast 只能改变运算对象的底层const。
    如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为；
    如果对象是一个常量，使用const_cast执行写操作就会产生未定义的后果；
    const_cast能改变表达式的常量属性，但不能改变表达式的类型；
    const_cast常常用于有函数重载的上下文中。
    3.reinterpret_cast 用于进行各种不同类型的指针之间、
    不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换。
    转换时，执行的是逐个比特复制的操作。
    reinterpret_cast本质上依赖于机器，
    想安全地使用reinterpret_cast必须对涉及的类型和和编译器实现转换的过程非常了解。
    4.dynamic_cast专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，
    而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 NULL 指针。
    reinterpret_cast 可以将多态基类（包含虚函数的基类）的指针强制转换为派生类的指针，
    但是这种转换不检查安全性，即不检查转换后的指针是否确实指向一个派生类对象。*/
/*3.旧式的强制类型转换
    type(expr);//函数形式的强制类型转换；
    (type)expr;//C语言分割的强制类型转换；
    旧式强制类型转换可用2中的方式替换*/
#include <iostream>
using namespace std;

int main()
{
    //4.11
    int val = 3.541 + 3; //int-->double
    //4.11.1
    bool flag = true;
    char cval = 'a';
    short sval = -100;
    unsigned short usval = 100;
    int ival = -200;
    unsigned int uival = 200;
    long lval = -300;
    unsigned long ulval = 300;
    float fval = 3.14159;
    double dval = 3.14159265;
    cout << 3.14159L + cval << endl; //char-->int-->long double
    cout << dval + ival << endl;     //int-->double
    cout << dval + fval << endl;     //float-->double
    cout << (ival = dval) << endl;   //double-->int
    cout << (flag = dval) << endl;   //double-->bool
    cout << cval + fval << endl;     //char-->int-->float
    cout << sval + cval << endl;     //short-->int,char-->int
    cout << cval + lval << endl;     //char-->long
    cout << ival + ulval << endl;    //int-->unsigned long
    cout << usval + ival << endl;    //根据unsigned short和int所占空间大小提升
    cout << uival + lval << endl;    //根据unsigned int和long所占空间大小转换
    //4.11.2
    int ia[10];   //含有10个元素的数组
    int *ip = ia; //ia转换成指向数组首元素的指针

    int i;
    const int &j = i;  //非常量转换成const int的引用
    const int *p = &i; //非常量转换成const 的地址
    //int &r = j, *q = p;//错误，不允许const转换成非常量

    string s, t = "a value";              //字符串字面值转换成string类型
    cout << ((cin >> s) ? s : t) << endl; //条件运算符，把cin转换成bool值

    //4.11.3
    int m = 5, n = 3;
    double slope = m / n; //结果是1
    cout << slope << endl;
    //进行强制类型转换以便执行浮点数除法
    slope = static_cast<double>(m) / n; //结果是1.66667
    cout << slope << endl;

    double d = 123.0;
    void *vp = &d; //正确：任何非常量对象都能存入void*
    //将void*转换回初始的指针类型
    double *dp = static_cast<double *>(vp);
    cout << *dp << endl;

    char ch = 'b';
    const char *chp = &ch;
    char *chq = const_cast<char *>(chp);                   //去底层const
    cout << static_cast<string>(chp) << endl;              //const char *类型强制转换成string类型
    cout << reinterpret_cast<const string *>(chp) << endl; //const char*强行转换const string *类型
    cout << static_cast<int>(*chp) << endl;                //const char类型转换成int 类型
    cout << (*chq = 's') << endl;                          //给接引用赋值，也改变了ch的值
    cout << ch << endl;

    int in = 98, *inp = &in;
    char *pc = reinterpret_cast<char *>(inp);
    char *pch = (char *)inp;
    string str(pc);
    cout << str << endl;
    return 0;
}
/*
100.142
-196.858
6.28318
3
1
100.142
-3
-203
303
103
4294967196
^Z
a value
1
1.66667
123
b�n
0x62fe0f
98
s
s
b
*/

/*4.12 运算符优先级表
//                        表4.4：运算符优先级
//+--------+------------------+---------------------------+------------------+
//| 结合律 | 运算符           | 用法                       功能              |
//+--------+------------------+---------------------------+------------------+
//|   左   | ::               | ::name                     全局作用域        |
//|   左   | ::               | class::name                类作用域          |
//|   左   | ::               | namespace::name            命名空间作用域    |
//+--------+------------------+---------------------------+------------------+
//|   左   | .                | object.member              成员选择          |
//|   左   | ->               | pointer->member            成员选择          |
//|   左   | [ ]              | expr[expr]                 下标              |
//|   左   | ( )              | name(expr_list)            函数调用          |
//|   左   | ( )              | type(expr_list)            类型构造          |
//+--------+------------------+---------------------------+------------------+
//|   右   | ++               | lvalue++                   后置递增运算      |
//|   右   | --               | lvalue--                   后置递减运算      |
//|   右   | typeid           | typeid(type)               类型ID            |
//|   右   | typeid           | typeid(expr)               运行时类型ID      |
//|   右   | explicit cast    | cast_name<type>(expr)      类型转换          |
//+--------+------------------+---------------------------+------------------+
//|   右   | ++               | ++lvalue                   前置递增运算      |
//|   右   | --               | --lvalue                   前置递减运算      |
//|   右   | ~                | ~expr                      位求反            |
//|   右   | !                | !expr                      逻辑非            |
//|   右   | -                | -expr                      一元负号          |
//|   右   | +                | +expr                      一元正号          |
//|   右   | *                | *expr                      接引用            |
//|   右   | &                | &expr                      取地址            |
//|   右   | ()               | (type)expr                 类型转换          |
//|   右   | sizeof           | sizeof expr                对象的大小        |
//|   右   | sizeof           | sizeof(type)               类型的大小        |
//|   右   | sizeof...        | sizeof...(name)            参数包的大小      |
//|   右   | new              | new type                   创建对象          |
//|   右   | new[]            | new type[size]             创建数组          |
//|   右   | delete           | delete expr                释放对象          |
//|   右   | delete[]         | delete[] expr              释放数组          |
//|   右   | noexcept         | noexcept(expr)             能否抛出异常      |
//+--------+------------------+---------------------------+------------------+
//|   左   | ->*              | ptr->*ptr_to_member        指向成员选择的指针|
//|   左   | .*               | obj.*ptr_to_member         指向成员选择的指针|
//+--------+------------------+---------------------------+------------------+
//|   左   | *                | expr * expr                乘法              |
//|   左   | /                | expr / expr                除法              |
//|   左   | %                | expr % expr                取模（取余)       |
//+--------+------------------+---------------------------+------------------+
//|   左   | +                | expr + expr                加法              |
//|   左   | -                | expr - expr                减法              |
//+--------+------------------+---------------------------+------------------+
//|   左   | <<               | expr << expr               向左位移          |
//|   左   | >>               | expr >> expr               向右位移          |
//+--------+------------------+---------------------------+------------------+
//|   左   | <                | expr < expr                小于              |
//|   左   | <=               | expr <= expr               小于等于          |
//|   左   | >                | expr > expr                大于              |
//|   左   | >=               | expr >= expr               大于等于          |
//+--------+------------------+---------------------------+------------------+
//|   左   | ==               | expr == expr               相等              |
//|   左   | !=               | expr != expr               不相等            |
//+--------+------------------+---------------------------+------------------+
//|   左   | &                | expr & expr                位与              |
//+--------+------------------+---------------------------+------------------+
//|   左   | ^                | expr ^ expr                位异或            |
//+--------+------------------+---------------------------+------------------+
//|   左   | |                | expr | expr                位或              |
//+--------+------------------+---------------------------+------------------+
//|   左   | &&               | expr && expr               逻辑与            |
//+--------+------------------+---------------------------+------------------+
//|   左   | ||               | expr || expr               逻辑或            |
//+--------+------------------+---------------------------+------------------+-
//|   右   | ?:               | expr ? expr : expr         条件              |
//+--------+------------------+---------------------------+------------------+
//|   右   | =                | lvalue = expr              赋值              |
//|   右   | *= , /= , %=     | lvalue += expr 等          复合赋值          |
//|   右   | += , -=          |                                              |
//|   右   | <<= , >>=        |                                              |
//|   右   | &= , |= , ^=     |                                              |
//+--------+------------------+---------------------------+------------------+
//|   右   | throw            |throw expr                  抛出异常          |
//+--------+------------------+---------------------------+------------------+
//|   左   | ,                | expr , expr                逗号              |
//+--------+------------------+---------------------------+------------------+
*/
