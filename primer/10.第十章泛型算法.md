# primer学习

## 第10章泛型算法

标准库容器定义的操作集合惊人得小。标准库并未给每个容器添加大量功能，而是提供了一组算法，这些算法中的大多数都独立于任何特定的容器。这些算法是通用的（generic，或称泛型的）：它们可用于不同类型的容器和不同类型的元素。

泛型算法和关于迭代器的更多细节，构成了本章的主要内容。

顺序容器只定义了很少的操作：在多数情况下，我们可以添加和删除元素、访问首尾元素、确定容器是否为空以及获得指向首元素或尾元素之后位置的迭代器。

我们可以想象用户可能还希望做其他很多有用的操作：查找特定元素、替换或删除一个特定值、重排元素顺序等。

标准库并未给每个容器都定义成员函数来实现这些操作，而是定义了一组泛型算法（generic algorithm）：称它们为“算法”，是因为它们实现了一些经典算法的公共接口，如排序和搜索；称它们是“泛型的”，是因为它们可以用于不同类型的元素和多种容器类型（不仅包括标准库类型，如vector或list，还包括内置的数组类型），以及我们将看到的，还能用于其他类型的序列。

### 10.1概述

大多数算法都定义在头文件algorithm中。标准库还在头文件numeric中定义了一组数值泛型算法。

一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围（参见9.2.1节，第296页）来进行操作。通常情况下，算法遍历范围，对其中每个元素进行一些处理。例如，假定我们有一个int的vector，希望知道vector中是否包含一个特定值。回答这个问题最方便的方法是调用标准库算法find：

```cpp
int val=42；//我们将查找的值
//如果在vec中找到想要的元素，则返回结果指向它，否则返回结果为vec.cend（）
auto result=find（vec.cbegin（），vec.cend（），val）；
//报告结果
cout<<"The value"<<val
<<（result==vec.cend（）
？"is not present"："is present"）<< endl；
```

传递给find的前两个参数是表示元素范围的迭代器，第三个参数是一个值。find将范围中每个元素与给定值进行比较。它返回指向第一个等于给定值的元素的迭代器。如果范围中无匹配元素，则find返回第二个参数来表示搜索失败。因此，我们可以通过比较返回值和第二个参数来判断搜索是否成功。我们在输出语句中执行这个检测，其中使用了条件运算符（参见4.7节，第134页）来报告搜索是否成功。
由于find操作的是迭代器，因此我们可以用同样的find函数在任何容器中查找值。
例如，可以用find在一个string的list中查找一个给定值：
string val="a value"；//我们要查找的值
//此调用在list中查找string元素
auto result=find（1st.cbegin（），1st.cend（），val）；类似的，由于指针就像内置数组上的迭代器一样，我们可以用find在数组中查找值：
int ia[]={27，210，12，47，109，83}；int val=83；int*result=find（begin（ia），end（ia），val）；此例中我们使用了标准库begin和end函数（参见3.5.3节，第106页）来获得指向ia中首元素和尾元素之后位置的指针，并传递给find。
还可以在序列的子范围中查找，只需将指向子范围首元素和尾元素之后位置的迭代器（指针）传递给find。例如，下面的语句在ia[1]、ia[2]和ia[3]中查找给定元素：
//在从ia[1]开始，直至（但不包含）ia[4]的范围内查找元素auto result=find（ia+1，ia+4，val）；算法如何工作
为了弄清这些算法如何用于不同类型的容器，让我们更近地观察一下find。find的工作是在一个未排序的元素序列中查找一个特定元素。概念上，find应执行如下步骤：
1.访问序列中的首元素。
2.比较此元素与我们要查找的值。
3.如果此元素与我们要查找的值匹配，find返回标识此元素的值。
4.否则，find前进到下一个元素，重复执行步骤2和3。
5.如果到达序列尾，find应停止。
6.如果find到达序列末尾，它应该返回一个指出元素未找到的值。此值和步骤3返回的值必须具有相容的类型。
这些步骤都不依赖于容器所保存的元素类型。因此，只要有一个迭代器可用来访问元素，find就完全不依赖于容器类型（甚至无须理会保存元素的是不是容器）。
迭代器令算法不依赖于容器，……
在上述find函数流程中，除了第2步外，其他步骤都可以用迭代器操作来实现：利用迭代器解引用运算符可以实现元素访问；如果发现匹配元素，find可以返回指向该元素的迭代器；用迭代器递增运算符可以移动到下一个元素；尾后迭代器可以用来判断find是否到达给定序列的末尾；find可以返回尾后迭代器（参见9.2.1节，第296页）来表示未找到给定元素。
…，但算法依赖于元素类型的操作
虽然迭代器的使用令算法不依赖于容器类型，但大多数算法都使用了一个（或多个）元素类型上的操作。例如，在步骤2中，find用元素类型的一运算符完成每个元素与给定值的比较。其他算法可能要求元素类型支持<运算符。不过，我们将会看到，大多数算法提供了一种方法，允许我们使用自定义的操作来代替默认的运算符。

关键概念：算法永远不会执行容器的操作
泛型算法本身不会执行容器的操作，它们只会运行于迭代器之上，执行迭代器的操作。泛型算法运行于迭代器之上而不会执行容器操作的特性带来了一个令人惊讶但非常必要的编程假定：算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。
如我们将在10.4.1节（第358页）所看到的，标准库定义了一类特殊的迭代器，称为插入器（inserter）。与普通送代器只能遍历所绑定的容器相比，插入器能做更多的事情。当给这类迭代器赋值时，它们会在底层的容器上执行插入操作。因此，当一个算法操作一个这样的迭代器时，迭代器可以完成向容器添加元素的效果，但算法自身永远不会做这样的操作。

10.2初识泛型算法
标准库提供了超过100个算法。幸运的是，与容器类似，这些算法有一致的结构。比起死记硬背全部100多个算法，理解此结构可以帮助我们更容易地学习和使用这些算法。在本章中，我们将展示如何使用这些算法，并介绍刻画了这些算法的统一原则。附录A按操作方式列出了所有算法。
除了少数例外，标准库算法都对一个范围内的元素进行操作。我们将此元素范围称为
“输入范围”。接受输入范围的算法总是使用前两个参数来表示此范围，两个参数分别是指向要处理的第一个元素和尾元素之后位置的迭代器。
虽然大多数算法遍历输入范围的方式相似，但它们使用范围中元素的方式不同。理解算法的最基本的方法就是了解它们是否读取元素、改变元素或是重排元素顺序。
10.2.1只读算法
一些算法只会读取其输入范围内的元素，而从不改变元素。find就是这样一种算法，我们在10.1节练习（第337页）中使用的count函数也是如此。
另一个只读算法是accumulate，它定义在头文件numeric中。accumulate函数接受三个参数，前两个指出了需要求和的元素的范围，第三个参数是和的初值。假定vec是一个整数序列，则：
//对vec中的元素求和，和的初值是0
int sum=accumulate（vec.cbegin（），vec.cend（），0）；这条语句将sum设置为vec中元素的和，和的初值被设置为0。
accumulate的第三个参数的类型决定了函数中使用哪个加法运算符以及返Nate回值的类型。
算法和元素类型
accumulate将第三个参数作为求和起点，这蕴含着一个编程假定：将元素类型加到和的类型上的操作必须是可行的。即，序列中元素的类型必须与第三个参数匹配，或者能够转换为第三个参数的类型。在上例中，vec中的元素可以是int，或者是double、1ong
1ong或任何其他可以加到int上的类型。
下面是另一个例子，由于string定义了+运算符，所以我们可以通过调用accumulate来将vector中所有string元素连接起来：
string sum=accumulate（v.cbegin（），v.cend（），string（""））；

此调用将v中每个元素连接到一个string上，该string初始时为空串。注意，我们通过第三个参数显式地创建了一个string。将空串当做一个字符串字面值传递给第三个参数是不可以的，会导致一个编译错误。
//错误：const char*上没有定义+运算符
string sum=accumulate（v.cbegin（），v.cend（），""）；原因在于，如果我们传递了一个字符串字面值，用于保存和的对象的类型将是const char*。如前所述，此类型决定了使用哪个+运算符。由于const char*并没有+运算符，此调用将产生编译错误。
对于只读取而不改变元素的算法，通常最好使用cbegin（）和cend（）（参见Best Pastices 9.2.3节，第298页）。但是，如果你计划使用算法返回的迭代器来改变元素的值，就需要使用begin（）和end（）的结果作为参数。
操作两个序列的算法
另一个只读算法是equa1，用于确定两个序列是否保存相同的值。它将第一个序列中的每个元素与第二个序列中的对应元素进行比较。如果所有对应元素都相等，则返回true，否则返回false。此算法接受三个迭代器：前两个（与以往一样）表示第一个序列中的元素范围，第三个表示第二个序列的首元素：
//roster2中的元素数目应该至少与roster1一样多equal（roster1.cbegin（），rosterl.cend（），roster2.cbegin（））；由于equa1利用迭代器完成操作，因此我们可以通过调用equa1来比较两个不同类型的容器中的元素。而且，元素类型也不必一样，只要我们能用一来比较两个元素类型即可。
例如，在此例中，roster1可以是vector<string>，而roster2是list<const char*>。
但是，equa1基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。此算法要处理第一个序列中的每个元素，它假定每个元素在第二个序列中都有一个与之对应的元素。
那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少4八与第一个序列一样长。
WARNING

10.2.2写容器元素的算法
一些算法将新值赋予序列中的元素。当我们使用这类算法时，必须注意确保序列原大小至少不小于我们要求算法写入的元素数目。记住，算法不会执行容器操作，因此它们自身不可能改变容器的大小。
一些算法会自己向输入范围写入元素。这些算法本质上并不危险，它们最多写入与给定序列一样多的元素。
例如，算法fi11接受一对迭代器表示一个范围，还接受一个值作为第三个参数。fil1将给定的这个值赋予输入序列中的每个元素。
fi1l（vec.begin（），vec.end（），0）；//将每个元素重置为0
//将容器的一个子序列设置为10
fi1l（vec.begin（），vec.begin（）+vec.size（）/2，10）；由于fi11向给定输入序列中写入数据，因此，只要我们传递了一个有效的输入序列，写入操作就是安全的。关键概念：迭代器参数
一些算法从两个序列中读取元素。构成这两个序列的元素可以来自于不同类型的容器。例如，第一个序列可能保存于一个vector中，而第二个序列可能保存于一个list、deque、内置数组或其他容器中。而且，两个序列中元素的类型也不要求严格匹配。算法要求的只是能够比较两个序列中的元素。例如，对equal算法，元素类型不要求相同，但是我们必须能使用一来比较来自两个序列中的元素。
操作两个序列的算法之间的区别在于我们如何传递第二个序列。一些算法，例如equa1，接受三个迭代器：前两个表示第一个序列的范围，第三个表示第二个序列中的首元素。其他算法接受四个迭代器：前两个表示第一个序列的元素范围，后两个表示第二个序列的范围。
用一个单一迭代器表示第二个序列的算法都假定第二个序列至少与第一个一样长。
确保算法不会试图访问第二个序列中不存在的元素是程序员的责任。例如，算法equal会将其第一个序列中的每个元素与第二个序列中的对应元素进行比较。如果第二个序列是第一个序列的一个子集，则程序会产生一个严重错误—equa1会试图访问第二个序列中末尾之后（不存在）的元素。
算法不检查写操作
一些算法接受一个迭代器来指出一个单独的目的位置。这些算法将新值赋予一个序列中的元素，该序列从目的位置迭代器指向的元素开始。例如，函数fi11n接受一个单迭代器、一个计数值和一个值。它将给定值赋予迭代器指向的元素开始的指定个元素。我们可以用fi11_n将一个新值赋予vector中的元素：
vector<int>vec；//空vector
//使用vec，赋予它不同值
fi11_n（vec.begin（），vec.size（），0）；//将所有元素重置为0函数fi11_n假定写入指定个元素是安全的。即，如下形式的调用fi1l_n（dest，n，val）
fi11_n假定dest指向一个元素，而从dest开始的序列至少包含n个元素。一个初学者非常容易犯的错误是在一个空容器上调用fi11_n（或类似的写元素的算法）：

vector<int>vec；//空向量
//灾难：修改vec中的10个（不存在）元素
fi11 n（vec.begin（），10，0）；这个调用是一场灾难。我们指定了要写入10个元素，但vec中并没有元素——它是空的。
这条语句的结果是未定义的。
A向目的位置迭代器写入数据的算法假定目的位置足够大，能容纳要写入的元WARNNG素。
介绍back inserter一种保证算法有足够元素空间来容纳输出数据的方法是使用插入迭代器（insert iterator）。插入迭代器是一种向容器中添加元素的迭代器。通常情况，当我们通过一个迭代器向容器元素赋值时，值被赋予迭代器指向的元素。而当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中。
我们将在10.4.1节中（第358页）详细介绍插入迭代器的内容。但是，为了展示如何用算法向容器写入数据，我们现在将使用back_inserter，它是定义在头文件iterator中的一个函数。
back_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用push back将一个具有给定值的元素添加到容器中：
vector<int>vec；//空向量
auto it=back inserter（vec）；//通过它赋值会将元素添加到vec中
*it=42；//vec中现在有一个元素，值为42我们常常使用back_inserter来创建一个迭代器，作为算法的目的位置来使用。例如：
‘vector<int>vec；//空向量
//正确：backinserter创建一个插入迭代器，可用来向vec添加元素fi11_n（back_inserter（vec），10，0）；//添加10个元素到vec在每步迭代中，fi11n向给定序列的一个元素赋值。由于我们传递的参数是back_inserter返回的迭代器，因此每次赋值都会在vec上调用push back。最终，这条fi11n调用语句向vec的末尾添加了10个元素，每个元素的值都是0.
拷贝算法
拷贝（copy）算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。传递给copy的目的序列至少要包含与输入序列一样多的元素，这一点很重要。
我们可以用copy实现内置数组的拷贝，如下面代码所示：
int al[]={0，1，2，3，4，5，6，7，8，9}；int a2[sizeof（a1）/sizeof（*a1）]；//a2与a1大小一样
//ret指向拷贝到a2的尾元素之后的位置
auto ret=copy（begin（a1），end（al），a2）；//把a1的内容拷贝给a2此例中我们定义了一个名为a2的数组，并使用sizeof确保a2与数组a1包含同样多的元素（参见4.9节，第139页）。接下来我们调用copy完成从a1到a2的拷贝。在调用copy后，两个数组中的元素具有相同的值。
copy返回的是其目的位置迭代器（递增后）的值。即，ret恰好指向拷贝到a2的尾元素之后的位置。
多个算法都提供所谓的“拷贝”版本。这些算法计算新元素的值，但不会将它们放置在输入序列的末尾，而是创建一个新序列保存这些结果。
例如，replace算法读入一个序列，并将其中所有等于给定值的元素都改为另一个值。此算法接受4个参数：前两个是迭代器，表示输入序列，后两个一个是要搜索的值，另一个是新值。它将所有等于第一个值的元素替换为第二个值：
//将所有值为0的元素改为42
replace（ilst.begin（），ilst.end（），0，42）；此调用将序列中所有的0都替换为42。如果我们希望保留原序列不变，可以调用replace_copy。此算法接受额外第三个迭代器参数，指出调整后序列的保存位置：
//使用back inserter按需要增长目标序列replace copy（ilst.cbegin（），ilst.cend（），back inserter（ivec），0，42）；此调用后，i1st并未改变，ivec包含ilst的一份拷贝，不过原来在ilst中值为0的元素在ivec中都变为42。


10.2.3重排容器元素的算法
某些算法会重排容器中元素的顺序，一个明显的例子是sort。调用sort会重排输入序列中的元素，使之有序，它是利用元素类型的<运算符来实现排序的。
例如，假定我们想分析一系列儿童故事中所用的词汇。假定已有一个vector，保存了多个故事的文本。我们希望化简这个vector，使得每个单词只出现一次，而不管单词在任意给定文档中到底出现了多少次。
为了便于说明问题，我们将使用下面简单的故事作为输入：

the quick red fox jumps over the slow red turtle给定此输入，我们的程序应该生成如下vector：
fox |jumps over quick red slow |the |turtle消除重复单词
为了消除重复单词，首先将vector排序，使得重复的单词都相邻出现。一旦vector排序完毕，我们就可以使用另一个称为unique的标准库算法来重排vector，使得不重复的元素出现在vector的开始部分。由于算法不能执行容器的操作，我们将使用vector的erase成员来完成真正的删除操作：
void elimpups（vector<string>&words）
//按字典序排序words，以便查找重复单词
sort（words.begin（），words.end（））；
//unique重排输入范围，使得每个单词只出现一次
//排列在范围的前部，返回指向不重复区域之后一个位置的选代器auto end_unique=unique（words.begin（），words.end（））；
//使用向量操作erase删除重复单词
words.erase（end unique，words.end（））；sort算法接受两个迭代器，表示要排序的元素范围。在此例中，我们排序整个vector。
完成sort后，words的顺序如下所示：
fox jumps over quick red red slow the the turtle注意，单词red和the各出现了两次。
使用unique words排序完毕后，我们希望将每个单词都只保存一次。unique算法重排输入序列，将相邻的重复项“消除”，并返回一个指向不重复值范围末尾的迭代器。调用unique后，vector将变为：
fox |jumps over Iquick red slow the turtle |？？？|？？？
end unique
（最后一个不重复元素之后的位置）words的大小并未改变，它仍有10个元素。但这些元素的顺序被改变了——相邻的重复元素被“删除”了。我们将删除打引号是因为unique并不真的删除任何元素，它只是覆盖相邻的重复元素，使得不重复元素出现在序列开始部分。unique返回的迭代器指向最后一个不重复元素之后的位置。此位置之后的元素仍然存在，但我们不知道它们的值是什么。
标准库算法对迭代器而不是容器进行操作。因此，算法不能（直接）添加或删
/Mate除元素。使用容器操作删除元素
为了真正地删除无用元素，我们必须使用容器操作，本例中使用erase（参见9.3.3节，第311页）。我们删除从end unique开始直至words末尾的范围内的所有元素。
这个调用之后，words包含来自输入的8个不重复的单词。
值得注意的是，即使words中没有重复单词，这样调用erase也是安全的。在此情况下，unique会返回words.end（）。因此，传递给erase的两个参数具有相同的值：
words.end（）。迭代器相等意味着传递给erase的元素范围为空。删除一个空范围没有什么不良后果，因此程序即使在输入中无重复元素的情况下也是正确的。

10.3定制操作
很多算法都会比较输入序列中的元素。默认情况下，这类算法使用元素类型的<或一运算符完成比较。标准库还为这些算法定义了额外的版本，允许我们提供自己定义的操作来代替默认运算符。
例如，sort算法默认使用元素类型的<运算符。但可能我们希望的排序顺序与<所定义的顺序不同，或是我们的序列可能保存的是未定义<运算符的元素类型（如Sales data）。在这两种情况下，都需要重载sort的默认行为。
10.3.1向算法传递函数
作为一个例子，假定希望在调用elimDups（参见10.2.3节，第343页）后打印vector的内容。此外还假定希望单词按其长度排序，大小相同的再按字典序排列。为了按长度重排vector，我们将使用sort的第二个版本，此版本是重载过的，它接受第三个参数，此参数是一个谓词（predicate）。
谓词
谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法所使用的谓词分为两类：一元谓词（unary predicate，意味着它们只接受单一参数）和二元谓词（binary predicate，意味着它们有两个参数）。接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型。
接受一个二元谓词参数的sort版本用这个谓词代替<来比较元素。我们提供给 sort的谓词必须满足将在11.2.2节（第378页）中所介绍的条件。当前，我们只需知道，此操作必须在输入序列中所有可能的元素值上定义一个一致的序。我们在6.2.2节（第189页）中定义的isshorter就是一个满足这些要求的函数，因此可以将isshorter传递给sort。这样做会将元素按大小重新排序：
//比较函数，用来按长度排序单词
bool isshorter（const string&sl，const string&s2）
return sl.size（）<s2.size（）；
//按长度由短至长排序words sort（words.begin（），words.end（），isshorter）；如果words包含的数据与10.2.3节（第343页）中一样，此调用会将words重排，使得所有长度为3的单词排在长度为4的单词之前，然后是长度为5的单词，依此类推。
排序算法
在我们将words按大小重排的同时，还希望具有相同长度的元素按字典序排列。为了保持相同长度的单词按字典序排列，可以使用stable_sort算法。这种稳定排序算法维持相等元素的原有顺序。
通常情况下，我们不关心有序序列中相等元素的相对顺序，它们毕竟是相等的。但是，在本例中，我们定义的“相等”关系表示“具有相同长度”。而具有相同长度的元素，如果看其内容，其实还是各不相同的。通过调用stable_sort，可以保持等长元素间的字典序：
elimDups（words）；//将words按字典序重排，并消除重复单词
//按长度重新排序，长度相同的单词维持字典序
stable sort（words.begin（），words.end（），isshorter）；for（const auto&s:words）//无须拷贝字符串cout<<s<<""；//打印每个元素，以空格分隔cout<<end1；假定在此调用前 words是按字典序排列的，则调用之后，words会按元素大小排序，而长度相同的单词会保持字典序。如果我们对原来的vector内容运行这段代码，输出为：
fox red the over slow jumps quick turtle

10.3.2lambda表达式
根据算法接受一元谓词还是二元谓词，我们传递给算法的谓词必须严格接受一个或两个参数。但是，有时我们希望进行的操作需要更多参数，超出了算法对谓词的限制。例如，为上一节最后一个练习所编写的程序中，就必须将大小5硬编码到划分序列的谓词中。如果在编写划分序列的谓词时，可以不必为每个可能的大小都编写一个独立的谓词，显然更有实际价值。
一个相关的例子是，我们将修改10.3.1节（第345页）中的程序，求大于等于一个给定长度的单词有多少。我们还会修改输出，使程序只打印大于等于给定长度的单词。

我们将此函数命名为biggies，其框架如下所示：
void biggies（vector<string>&words，vector<string>：：size type sz）
elimpups（words）；//将 words按字典序排序，删除重复单词
//按长度排序，长度相同的单词维持字典序
stable sort（words.begin（），words.end（），isshorter）；
//获取一个迭代器，指向第一个满足size（）>=sz的元素
//计算满足size>=sz的元素的数目
//打印长度大于等于给定值的单词，每个单词后面接一个空格
我们的新问题是在vector中寻找第一个大于等于给定长度的元素。一旦找到了这个元素，根据其位置，就可以计算出有多少元素的长度大于等于给定值。
我们可以使用标准库find_if算法来查找第一个具有特定大小的元素。类似find
（参见10.1节，第336页），find_if算法接受一对迭代器，表示一个范围。但与find不同的是，findif的第三个参数是一个谓词。findif算法对输入序列中的每个元素调用给定的这个谓词。它返回第一个使谓词返回非0值的元素，如果不存在这样的元素，则返回尾迭代器。
编写一个函数，令其接受一个string和一个长度，并返回一个bool值表示该string的长度是否大于给定长度，是一件很容易的事情。但是，find_if接受一元谓词一我们传递给find_if的任何函数都必须严格接受一个参数，以便能用来自输入序列的一个元素调用它。没有任何办法能传递给它第二个参数来表示长度。为了解决此问题，需要使用另外一些语言特性。
介绍lambda我们可以向一个算法传递任何类别的可调用对象（callable object）。对于一个对象或一个表达式，如果可以对其使用调用运算符（参见1.5.2节，第21页），则称它为可调用的。即，如果e是一个可调用的表达式，则我们可以编写代码e（args），其中args是一个逗号分隔的一个或多个参数的列表。
到目前为止，我们使用过的仅有的两种可调用对象是函数和函数指针（参见6.7节，第221页）。还有其他两种可调用对象：重载了函数调用运算符的类，我们将在14.8节（第506页）介绍，以及lambda表达式（lambda expression）。一个lambda表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数。与任何函数类似，一个lambda具有一个返回类型、一个参数列表和一个函数体。但与函数不同，lambda可能定义在函数内部。一个lambda表达式具有如下形式
[capture list]（parameter list）->return type{fiunction body
其中，capture list（捕获列表）是一个lambda所在函数中定义的局部变量的列表（通常为空）；return toype、parameter list 和function body与任何普通函数一样，分别表示返回类型、参数列表和函数体。但是，与普通函数不同，lambda必须使用尾置返回（参见6.3.3节，第206页）来指定返回类型。
我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体
autof=[]{return 42；}；

此例中，我们定义了一个可调用对象f，它不接受参数，返回42。
lambda的调用方式与普通函数的调用方式相同，都是使用调用运算符：
cout<<f（）<<endl；//打印42在lambda中忽略括号和参数列表等价于指定一个空参数列表。在此例中，当调用f时，参数列表是空的。如果忽略返回类型，lambda根据函数体中的代码推断出返回类型。如果函数体只是一个return语句，则返回类型从返回的表达式的类型推断而来。否则，返回类型为void。
如果lambda的函数体包含任何单一return语句之外的内容，且未指定返回
/ate 类型，则返回void。
向lambda传递参数
与一个普通函数调用类似，调用一个lambda时给定的实参被用来初始化lambda的形参。通常，实参和形参的类型必须匹配。但与普通函数不同，lambda不能有默认参数（参见6.5.1节，第211页）。因此，一个lambda调用的实参数目永远与形参数目相等。一旦形参初始化完毕，就可以执行函数体了。
作为一个带参数的lambda的例子，我们可以编写一个与isshorter函数完成相同功能的lambda：
[]（const string&a，const string&b）
{return a.size（）<b.size（）；}
空捕获列表表明此lambda不使用它所在函数中的任何局部变量。lambda的参数与isshorter的参数类似，是const string的引用。lambda的函数体也与isshorter类似，比较其两个参数的size（），并根据两者的相对大小返回一个布尔值。
如下所示，可以使用此lambda 来调用stable_sort：
//按长度排序，长度相同的单词维持字典序
stable sort（words.begin（），words.end（），
[]（const string&a，const string&b）
{return a.size（）<b.size（）；}）；当stable_sort 需要比较两个元素时，它就会调用给定的这个lambda表达式。
使用捕获列表
我们现在已经准备好解决原来的问题了一—编写一个可以传递给find_if的可调用表达式。我们希望这个表达式能将输入序列中每个string的长度与biggies函数中的sz参数的值进行比较。
虽然一个lambda可以出现在一个函数中，使用其局部变量，但它只能使用那些明确指明的变量。一个lambda通过将局部变量包含在其捕获列表中来指出将会使用这些变量。
捕获列表指引lambda在其内部包含访问局部变量所需的信息。
在本例中，我们的lambda会捕获sz，并只有单一的string参数。其函数体会将string的大小与捕获的sz的值进行比较：[sz]（const string&a）
{return a.size（）>=sz；}；

lambda以一对[]开始，我们可以在其中提供一个以逗号分隔的名字列表，这些名字都是它所在函数中定义的。
由于此lambda捕获sz，因此lambda的函数体可以使用sz。lambda不捕获words，因此不能访问此变量。如果我们给lambda提供一个空捕获列表，则代码会编译错误：
//错误：sz未捕获
[]（const string&a）
{return a.size（）>=sz；}；一个lambda 只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在
/Mate 函数体中使用该变量。
调用find if使用此lambda，我们就可以查找第一个长度大于等于sz的元素：
//获取一个迭代器，指向第一个满足size（）>=sz的元素auto wc=find if（words.begin（），words.end（），
[sz]（const string&a）
{return a.size（）>=sz；}）；这里对find_if的调用返回一个迭代器，指向第一个长度不小于给定参数sz的元素。
如果这样的元素不存在，则返回words.end（）的一个拷贝。
我们可以使用find_if返回的迭代器来计算从它开始到words的末尾一共有多少个元素（参见3.4.2节，第99页）：
//计算满足size>=sz的元素的数目
auto count=words.end（）-wc；cout << count<<""<<make plural（count，"word"，"s"）
<<"of length"<<sz<<"or longer"<<endl；我们的输出语句调用make_plural（参见6.3.2节，第201页）来输出“word”或“words”，具体输出哪个取决于大小是否等于1。
for_each 算法
问题的最后一部分是打印words中长度大于等于sz的元素。为了达到这一目的，我们可以使用for_each算法。此算法接受一个可调用对象，并对输入序列中每个元素调用此对象：
//打印长度大于等于给定值的单词，每个单词后面接一个空格for_each（wc，words.end（），
[]（const string ss）{cout<<s<<""；}）；cout<<end1；此lambda中的捕获列表为空，但其函数体中还是使用了两个名字：s和cout，前者是它自己的参数。
捕获列表为空，是因为我们只对lambda所在函数中定义的（非static）变量使用捕获列表。一个lambda可以直接使用定义在当前函数之外的名字。在本例中，cout不是定义在biggies中的局部名字，而是定义在头文件iostream中。因此，只要在biggies出现的作用域中包含了头文件iostream，我们的lambda就可以使用cout。

捕获列表只用于局部非static 变量，lambda可以直接使用局部static变
/Mate量和在它所在函数之外声明的名字。
完整的biggies到目前为止，我们已经解决了程序的所有细节，下面就是完整的程序：
void biggies（vector<string>&words，vector<string>：：size_type sz）
elimDups（words）；//将words按字典序排序，删除重复单词
//按长度排序，长度相同的单词维持字典序
stable_sort（words.begin（），words.end（），
[]（const string sa，const string sb）
{return a.size（）<b.size（）；}）；
//获取一个迭代器，指向第一个满足size（）>=sz的元素auto wc=find_if（words.begin（），words.end（），
[sz]（const string&a）
{return a.size（）>=sz；}）；
//计算满足size>=sz的元素的数目
auto count=words.end（）-wc；cout << count<<""<< make plural（count，"word"，"s"）
<<"of length"<<sz<<"or longer"<<endl；
//打印长度大于等于给定值的单词，每个单词后面接一个空格for each（wc，words.end（），
[]（const string&s）{cout<<s<<""；}）；cout<<endl；}

10.3.3 lambda捕获和返回
当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。我们将在14.8.1节（第507页）介绍这种类是如何生成的。目前，可以这样理解，当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象：传递的参数就是此编译器生成的类类型的未命名对象。类似的，当使用auto定义一个用lambda初始化的变量时，定义了一个从lambda生成的类型的对象。
默认情况下，从lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员。类似任何普通类的数据成员，lambda的数据成员也在lambda对象创建时被初始化。
值捕获
类似参数传递，变量的捕获方式也可以是值或引用。表10.1（第352页）列出了几种不同的构造捕获列表的方式。到目前为止，我们的lambda采用值捕获的方式。与传值参数类似，采用值捕获的前提是变量可以拷贝。与参数不同，被捕获的变量的值是在lambda创建时拷贝，而不是调用时拷贝：
void fcn1（）
sizet v1=42；//局部变量
//将v1拷贝到名为f的可调用对象
autof=[vl]{return v1；}；v1=0；autoj=f（）；//j为42；f保存了我们创建它时v1的拷贝由于被捕获变量的值是在lambda创建时拷贝，因此随后对其修改不会影响到lambda内对应的值。引用捕获
我们定义lambda时可以采用引用方式捕获变量。例如：
void fcn2（）
sizetvl=42；//局部变量
//对象f2包含v1的引用
auto f2=[6v1]{return v1；}；v1=0；autoj=f2（）；//j为0；f2保存v1的引用，而非拷贝v1之前的s指出v1应该以引用方式捕获。一个以引用方式捕获的变量与其他任何类型的引用的行为类似。当我们在lambda函数体内使用此变量时，实际上使用的是引用所绑定的对象。在本例中，当lambda返回v1时，它返回的是v1指向的对象的值。
引用捕获与返回引用（参见6.3.2节，第201页）有着相同的问题和限制。如果我们采用引用方式捕获一个变量，就必须确保被引用的对象在lambda执行的时候是存在的。
lambda 捕获的都是局部变量，这些变量在函数结束后就不复存在了。如果lambda可能在函数结束后执行，捕获的引用指向的局部变量已经消失。
引用捕获有时是必要的。例如，我们可能希望biggies函数接受一个ostream的引用，用来输出数据，并接受一个字符作为分隔符：
void biggies（vector<string>&words，vector<string>：：size type sz，ostream&os=cout，charc=''）
//与之前例子一样的重排words的代码
//打印count的语句改为打印到os for each（words.begin（），words.end（），
[sos，c]（const string&s）{os<<s<<c；}）；我们不能拷贝ostream对象（参见8.1.1节，第279页），因此捕获os的唯一方法就是捕获其引用（或指向os的指针）。
当我们向一个函数传递一个lambda时，就像本例中调用for_each那样，1ambda会立即执行。在此情况下，以引用方式捕获os没有问题，因为当for_each执行时，biggies中的变量是存在的。
我们也可以从一个函数返回lambda。函数可以直接返回一个可调用对象，或者返回一个类对象，该类含有可调用对象的数据成员。如果函数返回一个lambda，则与函数不能返回一个局部变量的引用类似，此lambda也不能包含引用捕获。
/！当以引用方式捕获一个变量时，必须保证在lambda执行时变量是存在的。
WARNING建议：尽量保持lambda的变量捕获简单化
一个lambda捕获从lambda被创建（即，定义lambda的代码执行时）到lambda自身执行（可能有多次执行）这段时间内保存的相关信息。确保lambda每次执行的时候这些信息都有预期的意义，是程序员的责任。
捕获一个普通变量，如int、string或其他非指针类型，通常可以采用简单的值捕获方式。在此情况下，只需关注变量在捕获时是否有我们所需的值就可以了。
如果我们捕获一个指针或迭代器，或采用引用捕获方式，就必须确保在lambda执行时，绑定到迭代器、指针或引用的对象仍然存在。而且，需要保证对象具有预期的值。
在lambda从创建到它执行的这段时间内，可能有代码改变绑定的对象的值。也就是说，在指针（或引用）被捕获的时刻，绑定的对象的值是我们所期望的，但在lambda执行时，该对象的值可能已经完全不同了。
一般来说，我们应该尽量减少捕获的数据量，来避免潜在的捕获导致的问题。而且，如果可能的话，应该避免捕获指针或引用。
隐式捕获
除了显式列出我们希望使用的来自所在函数的变量之外，还可以让编译器根据lambda体中的代码来推断我们要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个&或=。s告诉编译器采用捕获引用方式，=则表示采用值捕获方式。例如，我们可以重写传递给findif的lambda：
//sz为隐式捕获，值捕获方式
wc=find_if（words.begin（），words.end（），
[=]（const string&s）
{return s.size（）>=sz；}）；如果我们希望对一部分变量采用值捕获，对其他变量采用引用捕获，可以混合使用隐式捕获和显式捕获：
void biggies（vector<string>&words，
vector<string>：：size type sz，ostream sos=cout，charc=''）
//其他处理与前例一样
//os隐式捕获，引用捕获方式；c显式捕获，值捕获方式
for_each（words.begin（），words.end（），[&，c]（const string&s）{os<<s<<c；}）；
//os显式捕获，引用捕获方式；c隐式捕获，值捕获方式
for_each（words.begin（），words.end（），
[=，&os]（const string&s）{os<<s<<c；}）；当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个&或=。此符号指定了默认捕获方式为引用或值。
当混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方式。即，如果隐式捕获是引用方式（使用了s），则显式捕获命名变量必须采用值方式，因比不能在其名字前使用s。类似的，如果隐式捕获采用的是值方式（使用了=），则显式捕获命名变量必须采用引用方式，即，在名字前使用&。
表10.1：lambda 捕获列表
空捕获列表。lambda不能使用所在函数中的变量。一个lambda只有捕获变量后才能使用它们
[names]names是一个逗号分隔的名字列表，这些名字都是lambda所在函数的局部变量。默认情况下，捕获列表中的变量都被拷贝。名字前如果使用了&，则采用引用捕获方式
[&]
隐式捕获列表，采用引用捕获方式。lambda体中所使用的来自所在函数的实体都采用引用方式使用
[=]隐式捕获列表，采用值捕获方式。lambda体将拷贝所使用的来自所在函数的实体的值
ts，identifier_list]identifier_list是一个逗号分隔的列表，包含0个或多个来自所在函数的变量。这些变量采用值捕获方式，而任何隐式捕获的变量都采用引用方式捕获。identifier_list中的名字前面不能使用&
t=，identifier_list]identifier_list中的变量都采用引用方式捕获，而任何隐式捕获的变量都采用值方式捕获。identifier_list中的名字不能包括this，且这些名字之前必须使用。可变lambda默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable。因此，可变lambda能省略参数列表：
void fcn3（）
sizetv1=42；//局部变量
//f可以改变它所捕获的变量的值
autof=[v1]（）mutable{return ++v1；}；v1=0；autoj=f（）；//j为43
}
一个引用捕获的变量是否（如往常一样）可以修改依赖于此引用指向的是一个const类型还是一个非const类型：
void fcn4（）
sizetv1=42；//局部变量
//v1是一个非const变量的引用
//可以通过f2中的引用来改变它
auto f2=[&v1]{return ++vl；}；v1=0；autoj=f2（）；//j为1指定lambda返回类型
到目前为止，我们所编写的lambda都只包含单一的return语句。因此，我们还未遇到必须指定返回类型的情况。默认情况下，如果一个lambda体包含return之外的任何语句，则编译器假定此lambda返回void。与其他返回void的函数类似，被推断返回void的lambda不能返回值。
下面给出了一个简单的例子，我们可以使用标准库transform算法和一个lambda来将一个序列中的每个负数替换为其绝对值：
transform（vi.begin（），vi.end（），vi.begin（），
[]（int i）{returni<0？-i:i；}）；函数transform接受三个迭代器和一个可调用对象。前两个迭代器表示输入序列，第三个迭代器表示目的位置。算法对输入序列中每个元素调用可调用对象，并将结果写到目的位置。如本例所示，目的位置迭代器与表示输入序列开始位置的迭代器可以是相同的。当输入迭代器和目的迭代器相同时，transform将输入序列中每个元素替换为可调用对象操作该元素得到的结果。
在本例中，我们传递给transform一个lambda，它返回其参数的绝对值。lambda体是单一的return语句，返回一个条件表达式的结果。我们无须指定返回类型，因为可以根据条件运算符的类型推断出来。
但是，如果我们将程序改写为看起来是等价的if语句，就会产生编译错误：
//错误：不能推断1ambda的返回类型
transform（vi.begin（），vi.end（），vi.begin（），
[]（int i）{if（i<0）return-i；else return i；}）；编译器推断这个版本的lambda返回类型为void，但它返回了一个int值。
当我们需要为一个lambda定义返回类型时，必须使用尾置返回类型（参见6.3.3节，第206页）：
transform（vi.begin（），vi.end（），vi.begin（），
[]（int i）->int
{if（i<0）return-i；else return i；}）；在此例中，传递给transform的第四个参数是一个lambda，它的捕获列表是空的，接受单一int参数，返回一个int值。它的函数体是一个返回其参数的绝对值的if语句。

10.3.4参数绑定
对于那种只在一两个地方使用的简单操作，lambda表达式是最有用的。如果我们需要在很多地方使用相同的操作，通常应该定义一个函数，而不是多次编写相同的lambda表达式。类似的，如果一个操作需要很多语句才能完成，通常使用函数更好。
如果lambda的捕获列表为空，通常可以用函数来代替它。如前面章节所示，既可以用一个lambda，也可以用函数isshorter来实现将 vector中的单词按长度排序。类似的，对于打印vector内容的lambda，编写一个函数来替换它也是很容易的事情，这个函数只需接受一个string并在标准输出上打印它即可。
但是，对于捕获局部变量的lambda，用函数来替换它就不是那么容易了。例如，我们用在find_if调用中的lambda比较一个string和一个给定大小。我们可以很容易地编写一个完成同样工作的函数：
bool check size（const string&s，string:：size type sz）
return s.size（）>=sz；但是，我们不能用这个函数作为findif的一个参数。如前文所示，find if接受一个一元谓词，因此传递给findif的可调用对象必须接受单一参数。biggies传递给find_if的lambda使用捕获列表来保存sz。为了用checksize来代替此lambda，必须解决如何向sz形参传递一个参数的问题。
标准库bind函数
我们可以解决向checksize传递一个长度参数的问题，方法是使用一个新的名为bind的标准库函数，它定义在头文件functional中。可以将bind函数看作一个通用的函数适配器（参见9.6节，第329页），它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。
调用bind的一般形式为：
auto newCallable=bind（callable，arg_list）；其中，newCallable本身是一个可调用对象，arglist是一个逗号分隔的参数列表，对应给定的callable的参数。即，当我们调用newCalable时，newCallable会调用 callable，并传递给它arg list中的参数。
arg_list中的参数可能包含形如_n的名字，其中n是一个整数。这些参数是“占位符”，表示newCalable的参数，它们占据了传递给newCallable的参数的“位置”。数值n表示生成的可调用对象中参数的位置：1为newCalable的第一个参数，2为第二个参数，依此类推。
绑定 check_size的sz参数
作为一个简单的例子，我们将使用bind生成一个调用check_size的对象，如下所示，它用一个定值作为其大小参数来调用check_size：
//check6是一个可调用对象，接受一个string类型的参数
//并用此string和值6来调用check size auto check6=bind（check_size，_1，6）；此bind调用只有一个占位符，表示check6只接受单一参数。占位符出现在arg_list的第一个位置，表示check6的此参数对应check_size的第一个参数。此参数是一个const strings。因此，调用check6必须传递给它一个string类型的参数，check6会将此参数传递给 check_size。
strings="hello"；boolb1=check6（s）；//check6（s）会调用check_size（s，6）
使用bind，我们可以将原来基于lambda的find_if调用：
auto wc=find_if（words.begin（），words.end（），
[sz]（const string sa）
替换为如下使用checksize的版本：
auto wc=find if（words.begin（），words.end（），bind（check_size，1，sz））；此bind 调用生成一个可调用对象，将check_size的第二个参数绑定到sz的值。当find_if对words中的string 调用这个对象时，这些对象会调用check_size，将给定的string和sz传递给它。因此，find_if可以有效地对输入序列中每个string调用check_size，实现string的大小与sz的比较。
使用placeholders名字
名字n都定义在一个名为placeholders的命名空间中，而这个命名空间本身定义在std命名空间（参见3.1节，第74页）中。为了使用这些名字，两个命名空间都要写上。与我们的其他例子类似，对bind的调用代码假定之前已经恰当地使用了using声明。例如，1对应的using声明为：
using std:：placeholders:：_1；此声明说明我们要使用的名字_1定义在命名空间placeholders中，而此命名空间又定义在命名空间std中。
对每个占位符名字，我们都必须提供一个单独的using声明。编写这样的声明很烦人，也很容易出错。可以使用另外一种不同形式的using语句（详细内容将在18.2.2节（第702页）中介绍），而不是分别声明每个占位符，如下所示：
using namespace namespace name；这种形式说明希望所有来自namespace_name的名字都可以在我们的程序中直接使用。例如：
using namespace std:：placeholders；使得由placeholders定义的所有名字都可用。与bind函数一样，placeholders命名空间也定义在functiona1头文件中。
bind的参数
如前文所述，我们可以用bind修正参数的值。更一般的，可以用bind绑定给定可调用对象中的参数或重新安排其顺序。例如，假定f是一个可调用对象，它有5个参数，则下面对bind的调用：
//g是一个有两个参数的可调用对象
autog=bind（f，a，b，2，c，1）；生成一个新的可调用对象，它有两个参数，分别用占位符_2和1表示。这个新的可调用对象将它自己的参数作为第三个和第五个参数传递给f。f的第一个、第二个和第四个参数分别被绑定到给定的值a、b和c上。
传递给g的参数按位置绑定到占位符。即，第一个参数绑定到1，第二个参数绑定到
_2。因此，当我们调用g时，其第一个参数将被传递给f作为最后一个参数，第二个参数将被传递给f作为第三个参数。实际上，这个bind调用会将9（_1，2）映射为
f（a，b，2，c，1）
即，对g的调用会调用f，用g的参数代替占位符，再加上绑定的参数a、b和c。例如，调用g（x，Y）会调用
f（a，b，Y，c，X）用bind 重排参数顺序
下面是用bind重排参数顺序的一个具体例子，我们可以用bind颠倒isshroter的含义：
//按单词长度由短至长排序
sort（words.begin（），words.end（），isshorter）；
//按单词长度由长至短排序
sort（words.begin（），words.end（），bind（isshorter，_2，_1））；在第一个调用中，当sort需要比较两个元素A和B时，它会调用isshorter（A，B）。在第二个对sort的调用中，传递给isshorter的参数被交换过来了。因此，当sort比较两个元素时，就好像调用isshorter（B，A）一样。
绑定引用参数
默认情况下，bind的那些不是占位符的参数被拷贝到bind返回的可调用对象中。
但是，与lambda类似，有时对有些绑定的参数我们希望以引用方式传递，或是要绑定参数的类型无法拷贝。
例如，为了替换一个引用方式捕获ostream的lambda：
//os是一个局部变量，引用一个输出流
//c是一个局部变量，类型为char for_each（words.begin（），words.end（），
[&os，c]（const string&s）{os<<s<<c；}）；可以很容易地编写一个函数，完成相同的工作：
ostream&print（ostream&os，const string&s，char c）
return os<<s<<c；但是，不能直接用bind来代替对os的捕获：
//错误：不能拷贝os for_each（words.begin（），words.end（），bind（print，os，_1，））；原因在于bind拷贝其参数，而我们不能拷贝一个ostream。如果我们希望传递给bind一个对象而又不拷贝它，就必须使用标准库ref函数：
for_each（words.begin（），words.end（），bind（print，ref（os），1，'））；函数ref返回一个对象，包含给定的引用，此对象是可以拷贝的。标准库中还有一个cref函数，生成一个保存const引用的类。与bind一样，函数ref和cref也定义在头文件functional中。
向后兼容：参数绑定
旧版本C++提供的绑定函数参数的语言特性限制更多，也更复杂。标准库定义了两个分别名为bindlst和bind2nd的函数。类似bind，这两个函数接受一个函数作为参数，生成一个新的可调用对象，该对象调用给定函数，并将绑定的参数传递给它。但是，这些函数分别只能绑定第一个或第二个参数。由于这些函数局限太强，在新标准中已被弃用（deprecated）。所谓被弃用的特性就是在新版本中不再支持的特性。新的C++程序应该使用bind。

10.4再探迭代器
除了为每个容器定义的迭代器之外，标准库在头文件iterator中还定义了额外几种迭代器。这些迭代器包括以下几种。
·插入迭代器（insert iterator）：这些迭代器被绑定到一个容器上，可用来向容器插入元素。
·流迭代器（stream iterator）：这些迭代器被绑定到输入或输出流上，可用来遍历所关联的IO流。
·反向迭代器（reverse iterator）：这些迭代器向后而不是向前移动。除了forward_list之外的标准库容器都有反向迭代器。
·移动迭代器（move iterator）：这些专用的迭代器不是拷贝其中的元素，而是移动它们。我们将在13.6.2节（第480页）介绍移动迭代器。
10.4.1插入迭代器
插入器是一种迭代器适配器（参见9.6节，第329页），它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们通过一个插入迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。表10.2列出了这种迭代器支持的操作。
表10.2：插入迭代器操作
|it=t在it指定的当前位置插入值t。假定c是it绑定的容器，依赖于插入迭代器的不同种类，此赋值会分别调用c.push_back（t）、c.push_front（t）或c.insert（t，p），其中p为传递给inserter的迭代器位置
|*it，++it，it++这些操作虽然存在，但不会对it做任何事情。每个操作都返回it插入器有三种类型，差异在于元素插入的位置：
·back inserter（参见10.2.2节，第341页）创建一个使用push back的迭代器。
·front inserter创建一个使用push front的迭代器。
·inserter创建一个使用insert的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。
只有在容器支持push_front的情况下，我们才可以使用front inserter。
/Nate类似的，只有在容器支持push_back的情况下，我们才能使用back_inserter。
理解插入器的工作过程是很重要的：当调用inserter（c，iter）时，我们得到一个迭代器，接下来使用它时，会将元素插入到iter原来所指向的元素之前的位置。即，如果it是由inserter生成的迭代器，则下面这样的赋值语句
*it=val；其效果与下面代码一样
it=c.insert（it，val）；//it 指向新加入的元素
++it；//递增it使它指向原来的元素
front inserter生成的迭代器的行为与inserter生成的迭代器完全不一样。当我们使用front_inserter时，元素总是插入到容器第一个元素之前。即使我们传递给inserter的位置原来指向第一个元素，只要我们在此元素之前插入一个新元素，此元素就不再是容器的首元素了：
list<int>lst={1，2，3，4}；list<int>1st2，1st3；//空list
//拷贝完成之后，1st2包含4321
copy（1st.cbegin（），1st.cend（），front_inserter（1st2））；
//拷贝完成之后，1st3包含1234
copy（1st.cbegin（），1st.cend（），inserter（1st3，1st3.begin（）））；当调用front inserter（c）时，我们得到一个插入迭代器，接下来会调用push front。当每个元素被插入到容器c中时，它变为c的新的首元素。因此，front inserter生成的迭代器会将插入的元素序列的顺序颠倒过来，而inserter和back inserter则不会。

10.4.2 iostream迭代器
虽然iostream类型不是容器，但标准库定义了可以用于这些I0类型对象的迭代器（参见8.1节，第278页）。istream_iterator（参见表10.3）读取输入流，ostream iterator（参见表10.4节，第361页）向一个输出流写数据。这些迭代器将它们对应的流当作一个特定类型的元素序列来处理。通过使用流迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。
istream iterator操作
当创建一个流迭代器时，必须指定迭代器将要读写的对象类型。一个istream_iterator 使用>>来读取流。因此，istream iterator 要读取的类型必须定义了输入运算符。当创建一个istream iterator时，我们可以将它绑定到一个流。
当然，我们还可以默认初始化迭代器，这样就创建了一个可以当作尾后值使用的迭代器。
istream_iterator<int>int_it（cin）；//从cin读取int istream_iterator<int>int_eof；//尾后迭代器ifstream in（"afile"）；istream iterator<string>str it（in）；//从”afile“读取字符串下面是一个用istream iterator从标准输入读取数据，存入一个vector的例子：
istream_iterator<int>in iter（cin）；//从cin 读取int istream iterator<int>eof；//istream尾后迭代器while（in iter！=eof）//当有数据可供读取时
//后置递增运算读取流，返回迭代器的旧值//解引用迭代器，获得从流读取的前一个值
vec.push_back（*in_iter++）；
此循环从cin读取int值，保存在vec中。在每个循环步中，循环体代码检查in_iter是否等于eof。eof被定义为空的istreamiterator，从而可以当作尾后迭代器来使用。对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或遇到10错误，迭代器的值就与尾后迭代器相等。
此程序最困难的部分是传递给 push back的参数，其中用到了解引用运算符和后置递增运算符。该表达式的计算过程与我们之前写过的其他结合解引用和后置递增运算的表达式一样（参见4.5节，第131页）。后置递增运算会从流中读取下一个值，向前推进，但返回的是迭代器的旧值。迭代器的旧值包含了从流中读取的前一个值，对迭代器进行解引用就能获得此值。
我们可以将程序重写为如下形式，这体现了istreamiterator更有用的地方：
istream iterator<int>in_iter（cin），eof；//从cin读取int vector<int>vec（in iter，eof）；//从迭代器范围构造vec本例中我们用一对表示元素范围的迭代器来构造vec。这两个迭代器是istreamiterator，这意味着元素范围是通过从关联的流中读取数据获得的。这个构造函数从cin中读取数据，直至遇到文件尾或者遇到一个不是int的数据为止。从流中读取的数据被用来构造vec。
表10.3：istream iterator 操作
istream iterator<T>in（is）；in从输入流is读取类型为T的值istream_iterator<T>end；读取类型为T的值的istream iterator迭代器，表示尾后位置
in1==in2in1和in2必须读取相同类型。如果它们都是尾后迭代器，或绑定到相同in1！=in2的输入，则两者相等
返回从流中读取的值
in->mem与（*in）.mem的含义相同
++in，in++使用元素类型所定义的>>运算符从输入流中读取下一个值。与以往一样，前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值使用算法操作流迭代器
由于算法使用迭代器操作来处理数据，而流迭代器又至少支持某些迭代器操作，因此我们至少可以用某些算法来操作流迭代器。我们在10.5.1节（第365页）会看到如何分辨哪些算法可以用于流迭代器。下面是一个例子，我们可以用一对istream_iterator来调用accumulate：
istream iterator<int>in（cin），eof；cout<<accumulate（in，eof，0）<< endl；此调用会计算出从标准输入读取的值的和。如果输入为：
23 109458963412903423562388923则输出为664。
istream_iterator允许使用懒惰求值
当我们将一个istream iterator绑定到一个流时，标准库并不保证迭代器立即从流读取数据。具体实现可以推迟从流中读取数据，直到我们使用迭代器时才真正读取。标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了。对于大多数程序来说，立即读取还是推迟读取没什么差别。但是，如果我们创建了一个istream iterator，没有使用就销毁了，或者我们正在从两个不同的对象同步读取同一个流，那么何时读取可能就很重要了。
ostream iterator操作
我们可以对任何具有输出运算符（<<运算符）的类型定义ostreamiterator。当创建一个ostream iterator时，我们可以提供（可选的）第二参数，它是一个字符串，在输出每个元素后都会打印此字符串。此字符串必须是一个C风格字符串（即，一个字符串字面常量或者一个指向以空字符结尾的字符数组的指针）。必须将ostreamiterator绑定到一个指定的流，不允许空的或表示尾后位置的ostream_iterator。
表10.4：ostream_iterator 操作
ostream_iterator<T> out（os）；out 将类型为T的值写到输出流os中ostream_iterator<T> out（os，d）；out 将类型为T的值写到输出流os中，每个值|
后面都输出一个d。d指向一个空字符结尾的字
符数组
|out=val用<运算符将va1写入到out 所绑定的ostream中。va1的类|
型必须与out可写的类型兼容
|*out，++out，out++这些运算符是存在的，但不对out做任何事情。每个运算符都返回|
out我们可以用ostream iterator来输出值的序列：
ostream iterator<int>out iter（cout，""）；for（autoe:vec）
*out iter++=e；//赋值语句实际上将元素写到cout cout<<endl；此程序将vec中的每个元素写到cout，每个元素后加一个空格。每次向out iter赋值时，写操作就会被提交。
值得注意的是，当我们向outiter赋值时，可以忽略解引用和递增运算。即，循环可以重写成下面的样子：
for（auto e:vec）
out_iter=e；//赋值语句将元素写到cout cout<<end1；运算符*和++实际上对ostream_iterator对象不做任何事情，因此忽略它们对我们的程序没有任何影响。但是，推荐第一种形式。在这种写法中，流迭代器的使用与其他迭代器的使用保持一致。如果想将此循环改为操作其他迭代器类型，修改起来非常容易。而且，对于读者来说，此循环的行为也更为清晰。
可以通过调用copy来打印vec中的元素，这比编写循环更为简单：
copy（vec.begin（），vec.end（），out_iter）；cout<<end1；
使用流迭代器处理类类型
我们可以为任何定义了输入运算符（>>）的类型创建istream iterator对象。类似的，只要类型有输出运算符（<<），我们就可以为其定义ostream_iterator。由于Salesitem既有输入运算符也有输出运算符，因此可以使用IO迭代器重写1.6节（第21页）中的书店程序：
istream iterator<Sales item>item iter（cin），eof；ostream iterator<Sales item>out iter（cout，"\n"）；
//将第一笔交易记录存在sum中，并读取下一条记录Sales item sum=*item iter++；while（item iter！=eof）{
//如果当前交易记录（存在itemiter中）有着相同的ISBN号if（item iter->isbn（）==sum.isbn（））
sum+=*item iter++；//将其加到sum上并读取下一条记录else{
out iter=sum；//输出sum当前值
sum=*item iter++；//读取下一条记录out iter=sum；//记得打印最后一组记录的和此程序使用item_iter从cin 读取sales_item交易记录，并将和写入cout，每个结果后面都跟一个换行符。定义了自己的迭代器后，我们就可以用item_iter读取第一条交易记录，用它的值来初始化sum：
//将第一条交易记录保存在sum中，并读取下一条记录Sales item sum=*item iter++；此处，我们对itemiter执行后置递增操作，对结果进行解引用操作。这个表达式读取下一条交易记录，并用之前保存在item_iter中的值来初始化sum。
while循环会反复执行，直至在cin上遇到文件尾为止。在while循环体中，我们检查sum与刚刚读入的记录是否对应同一本书。如果两者的ISBN不同，我们将sum赋予out iter，这将会打印sum的当前值，并接着打印一个换行符。在打印了前一本书的交易金额之和后，我们将最近读入的交易记录的副本赋予sum，并递增迭代器，这将读取下一条交易记录。循环会这样持续下去，直至遇到错误或文件尾。在退出之前，记住要打印输入中最后一本书的交易金额之和。

10.4.3反向迭代器
反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。递增一个反向迭代器（++it）会移动到前一个元素；递减一个迭代器（—it）会移动到下一个元素。
除了forward list之外，其他容器都支持反向迭代器。我们可以通过调用rbegin、rend、crbegin和crend成员函数来获得反向迭代器。这些成员函数返回指向容器尾元素和首元素之前一个位置的迭代器。与普通迭代器一样，反向迭代器也有const和非const版本。
图10.1显示了一个名为vec的假设的vector上的4种迭代器：
vec.cbegin（）vec.cend（）
vec.crend（）vec.crbegin（）
图10.1：比较cbegin/cend和crbegin/crend下面的循环是一个使用反向迭代器的例子，它按逆序打印vec中的元素：
vector<int>vec={0，1，2，3，4，5，6，7，8，9}；
//从尾元素到首元素的反向迭代器
for（auto r_iter=vec.crbegin（）；//将riter绑定到尾元素r_iter！=vec.crend（）；//crend指向首元素之前的位置
++r iter）
//实际是递减，移动到前一个元素
cout<<*r_iter<<endl；//打印9，8，7，..0虽然颠倒递增和递减运算符的含义可能看起来令人混淆，但这样做使我们可以用算法透明地向前或向后处理容器。例如，可以通过向sort传递一对反向迭代器来将vector整理为递减序：
sort（vec.begin（），vec.end（））；//按“正常序”排序vec
//按逆序排序：将最小元素放在vec的末尾
sort（vec.rbegin（），vec.rend（））；反向迭代器需要递减运算符
不必惊讶，我们只能从既支持++也支持一的迭代器来定义反向迭代器。毕竟反向迭代器的目的是在序列中反向移动。除了forward_list之外，标准容器上的其他迭代器都既支持递增运算又支持递减运算。但是，流迭代器不支持递减运算，因为不可能在一个流中反向移动。因此，不可能从一个forward list或一个流迭代器创建反向迭代器。
反向迭代器和其他迭代器间的关系
假定有一个名为1ine的string，保存着一个逗号分隔的单词列表，我们希望打印
