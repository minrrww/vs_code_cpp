string 支持可变长字符串
vector 支持可变长集合
迭代器 是string和vector的配套类型

3.1 命名空间的using声明
std::cin,std::cout
编译器从操纵符左侧名字所示的作用域寻找右侧那个名字

using namespace::name;
//每个名字都要独立的using声明
using std::cin;
using std::cout;
另外，可以声明
using namespace std;//无需每个名字独立声明

头文件中不应包含using声明，因为如果头文件中有了using声明，
每个使用了头文件的文件就都会有using声明，容易产生始料未及的名字冲突

3.2 标准库类型 string
使用string前，要包含string
#include <string>
using std::string;

3.2.1 定义和初始化string对象
一个类可以定义很多种初始化对象的方式：或者初始值数量不同，或者初始值的类型不同
//example-3.2.1-.cpp
#include <iostream>
using namespace std;
int main()
{
    string s1;                  //默认初始化，s1是一个空字符串
    string s2 = s1;             //s2是s1的副本
    string s3(s2);              //s3是s1的副本
    string s4 = "hiya";         //s4是该字符串字面值（除最后的空字符外）的副本
    string s5("hiya");          //s5是该字符串字面值（除最后的空字符外）的副本
    string s6(10, 'c');         //s6的内容是cccccccccc;
    string s7{15, 'b'};         //s7的内容是b;
    string s8 = {"15", "cdf"};  //s8的内容是15;
    string s9{"15", "cdf"};     //s9的内容是15;
    string s10 = string("ABC"); //s9的内容是ABC;
    cout << s1 << endl;
    cout << s2 << endl;
    cout << s3 << endl;
    cout << s4 << endl;
    cout << s5 << endl;
    cout << s6 << endl;
    cout << s7 << endl;
    cout << s8 << endl;
    cout << s9 << endl;
    cout << s10 << endl;
    return 0;
}
/*



hiya
hiya
cccccccccc
b
15
15
ABC
 */

可以用字符串变量、字符串字面值、圆括号、花括号、string()通过拷贝初始化“=”或直接初始化
圆括号必须带参数，否则会被当函数声明
花括号读取第一个字面值字符串或字符否则为空字符串

3.2.2 string 对象上的操作
1.函数操作
2.运算符新含义
//example-3.2.2-.cpp
#include <iostream>
using namespace std;
int main()
{
    string s, s1, s2;    //默认初始化，s是一个空字符串
    cin >> s1;           //在cin流对象中读取值，赋给s,字符以空格为界，返回cin
    cout << s1 << endl;  //将s写到cout流对象中，返回cout

    getline(cin, s2);    //在cin流对象中读取一行赋给s,返回cin，,s2中不包括换行符
    bool b = s2.empty(); //s为空返回true,否则返回false
    auto i = s2.size();  //返回s中字符的个数,i为size_type类型的对象
    char c = s2[s2.size() - 1];//返回s最后一个字符
    cout << s2 << b << i << c << endl;
    s = s1 + s2;//连接
    cout << s << endl;
    //利用字符在字典中的顺序进行比较，且对字母大小写敏感名，比较第一个相异的字符大小
    cout << (s1 < s2) << (s1 > s2) << (s1 <= s2) << (s1 >= s2) << endl;
    s1 = s2;//用s2副本代替s1原来的值
    cout << s1 << endl;
    cout << s2 << endl;
    if(s1==s2)
        cout << (s1 != s2 )<< endl;
    return 0;
}
/*
abc abc
abc
 abc04c
abc abc
0101
 abc
 abc
0
 */
字符串字面值和string对象相加：字符串字面值不能直接相加
字符串字面值和string对象不是同一类型

3.2.3 处理string对象中的字符
cctype头文件中的函数
isalnum(c) 当c是字母或数字时为真
isalpha(c) 当c是字母时为真
iscntrl(c) 当c是控制符时为真
isdigit(c) 当c是数字时为真
isgraph(c) 当c是不是空格但可以打印时为真
islower(c) 当c是小写字母时为真
isprint(c) 当c是可打印字符时为真（即c是空格或具有可视形式）
ispunct(c) 当c是标点符号时为真
isspace(c) 当c是空白时为真（即c使空格、横向纵向制表符、回车符、换行符、进纸符中的一种）
isupper(c) 当c是十六进制数字时为真
isxdigit(c) 当c是字母或数字时为真
tolower(c) 如果c是大写字母，输出对应的小写字母；否则原样输出c
toupper(c) 如果c是小写字母，输出对应的大写字母；否则原样输出c

处理每个字符？使用基于范围的for语句

#include <iostream>
using namespace std;
int main()
{
    string s("Hello World!!!");
    //punct_cnt的类型和s.size的返回类型一样；
    decltype(s.size()) punct_cnt = 0;
    for (auto c : s)//s中的每一个字符
        if (ispunct(c))//如果该字符是标点符号
            ++punct_cnt;//将标点符号的计数值加1
    cout << punct_cnt
         << " punctuation characters in " << s << endl;
    return 0;
}
/*
3 punctuation characters in Hello World!!!
*/

#include <iostream>
using namespace std;
int main()
{
    string s("Hello World!!!");
    //punct_cnt的类型和s.size的返回类型一样；
    decltype(s.size()) punct_cnt = 0;
    for (auto &c : s) //s中的每一个字符(c是引用，复制将改变s中的字符)
    {
        c = toupper(c);  //c是引用，复制将改变s中的字符
        if (ispunct(c))  //如果该字符是标点符号
            ++punct_cnt; //将标点符号的计数值加1
    }
    cout << punct_cnt
         << " punctuation characters in " << s << endl;
    return 0;
}
/*
3 punctuation characters in HELLO WORLD!!!
*/

只处理一部分字符？
1.使用下标
2.使用迭代器
#include <iostream>
using namespace std;
int main()
{
    string s("Hello World!!!");
    //punct_cnt的类型和s.size的返回类型一样；
    decltype(s.size()) punct_cnt = 0;
    for (auto &c : s) //s中的每一个字符(c是引用，复制将改变s中的字符)
    {
        c = toupper(c);  //c是引用，复制将改变s中的字符
        if (ispunct(c))  //如果该字符是标点符号
            ++punct_cnt; //将标点符号的计数值加1
    }
    cout << punct_cnt
         << " punctuation characters in " << s << endl;
    string s1("some string");
    if (!s1.empty())            //确保s[0]位置有字符
        s1[0] = toupper(s1[0]); //第一字符大写
    cout << s1 << endl;
    //依次处理s中的字符直到处理完全部字符或遇到一个空白
    for (decltype(s1.size()) index = 0; index < s1.size() && !isspace(s1[index]); ++index)
        s1[index] = toupper(s1[index]); //当前字符大写
    cout << s1 << endl;
    return 0;
}
/*
3 punctuation characters in HELLO WORLD!!!
Some string
SOME string
*/

#include <iostream>
using namespace std;
int main()
{
    const string hexdigits = "0123456789ABCDEF"; //可能的十六进制数字
    cout << "Enter a series of numbers between 0 and 15"
         << " separated by spaces. Hit ENTER when finished: "
         << endl;
    string result;       //用于保存十六进制字符串
    string::size_type n; //用于保存从输入流读取的数
    while (cin >> n)
        if (n < hexdigits.size())   //忽略无效输入
            result += hexdigits[n]; //得到对应的十六进制数字
    cout << "Your hex number is: " << result << endl;
    return 0;
}
/*
Enter a series of numbers between 0 and 15 separated by spaces. Hit ENTER when finished:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15^Z
Your hex number is: 123456789ABCDEF
*/

3.3 标准库类型vector
标准库类型vector表示对象的集合，其中所有对象的类型都相同，也被称为容器（container）
#include <vector>
using namespace std;
c++既有类模板（class template），也有函数模板
vector是一个类模板 模板不是类或函数，可看作编译器生成类或函数编写的一份说明
编译器根据模板创建类或函数的过程称为实例化（istantiation）
vector<int> ivec;//ivec保存int 类型的对象
vector<SalesItem> salesVec;//salesVec保存SalesItem类型的对象
vector<vector<stirng>> file;//该向量的元素是vector<string>类型的对象
引用不是对象，vector不保护引用

3.3.1 定义和初始化vector对象
初始化vector对象的方法
不能使用字符串字面值创建vector对象
//example-3.3.1-.cpp
#include <iostream>
#include <vector>
using namespace std;
int main()
{
    vector<int> v1;      //v1是一个空vector，int类型
    vector<int> v2(v1);  //v2包含v1所有元素副本
    vector<int> v3 = v1; //v3包含v1所有元素副本
    int n = 5, val = 5;
    vector<int> v4(n, val);//v4包含5个5
    //vector<string> v5('5');//不能使用字符串字面值创建vector 对象
    vector<int> v5{1, 2, 3, 4, 5, 6};    //v5包含1, 2, 3, 4, 5, 6
    vector<int> v6 = {9, 8, 7, 6, 5, 4}; //v6包含9, 8, 7, 6, 5, 4
    vector<int> v7 = vector<int>(v6);    //v7包含v6全部副本
    vector<int> v8(10);                  //10个元素，都是0
    vector<string> v9(10);               //10个元素，都是""
    return 0;
}


3.3.2 向vector对象中添加元素

vector的成员函数push_back()，向vector对象的尾端添加元素
范围for语句体内不应改变其所遍历序列的大小
不能以下标添加元素
//example-3.3.2-.cpp
#include <iostream>
#include <vector>
using namespace std;
int main()
{
    vector<int> v1, v2; //空vector对象
    for (int i = 0; i != 100; i++)
        v2.push_back(i); //依次把整数值放到v2尾端
    //循环结束后v2有100个元素，值丛0-99

    //从标准库中读取单词，将其作为vector对象的元素
    /*string word;
    vector<string> text; //空vector对象
    while (cin >> word)
    {
        text.push_back(word); //把word添加到text后面
    }*/
    if (!v2.empty())
        cout << v2.size() << v2[v2.size() - 1] << endl;
    v1 = v2;
    if (!(v1 != v2))
        cout << (v1 == v2) << (v1 < v2) << (v1 > v2) << (v1 <= v2) << (v1 >= v2) << endl;

    for (auto &i : v2)
        i *= i;

    //decltype(v2.size())可以用vector<int>::size_type代替
    for (decltype(v2.size()) i = 0; i < v2.size(); i++)
    {
        if ((i + 1) % 10)
            cout << v2[i] << "\t";
        else
            cout << v2[i] << endl;
    }
    cout << endl;
    //以10分为一个分数段统计成绩单数量：0~9，……，100
    unsigned grade;
    vector<unsigned> scores(11, 0); //11个分数段，全部初始值为0
    while (cin >> grade)            //读取成绩
    {
        if (grade <= 100)         //只处理有效成绩
            ++scores[grade / 10]; //将对应的分数段的计数器加1
    }
    for (unsigned s : scores)
        cout << s << " ";
    cout << endl;
    return 0;
}
/*
123
^Z
10099
10011
0       1       4       9       16      25      36      49      64      81
100     121     144     169     196     225     256     289     324     361
400     441     484     529     576     625     676     729     784     841
900     961     1024    1089    1156    1225    1296    1369    1444    1521
1600    1681    1764    1849    1936    2025    2116    2209    2304    2401
2500    2601    2704    2809    2916    3025    3136    3249    3364    3481
3600    3721    3844    3969    4096    4225    4356    4489    4624    4761
4900    5041    5184    5329    5476    5625    5776    5929    6084    6241
6400    6561    6724    6889    7056    7225    7396    7569    7744    7921
8100    8281    8464    8649    8836    9025    9216    9409    9604    9801
42 65 95 100 39 67 95 76 88 76 83 92 76 93^Z
0 0 0 1 1 0 2 3 2 4 1
*/

3.4 迭代器介绍
通用的访问string对象的字符或vector对象的元素的方法，就是迭代器（iterator）
string对象不属于容器，但和vector及其他几种容器，支持迭代器
迭代器类似于指针

3.4.1 使用迭代器
获取迭代器不用取地址符，迭代器类型有返回迭代器的成员
begin 返回指向第一个元素或第一个字符的迭代器
end 返回容器或string对象尾元素的下一位置，称为尾后迭代器（off-the-end iterator）
如果容器为空，begin和end返回的都是尾后迭代器
不知道迭代器的类型，用auto类型

*iter  返回迭代器iter所指元素的引用
iter->mem 解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem
++iter 令iter指向容器中的下一个元素
--iter 令iter指向容器中的上一个元素
iter1==iter2 迭代器是否相等，如果两个迭代器指向的是同一个元素或者它们是同一个容器的尾后迭代器
iter1！=iter2 和上面相反

//example-3.4.1-.cpp
include <iostream>
using namespace std;
int main()
{
    string s("some string");
    if (s.begin() != s.end()) //确保s非空
    {
        auto it = s.begin(); //it表示s的第一个字符
        *it = toupper(*it);  //将当前字符改写成大写形式
    }
    cout << s << endl;
    //依次处理s的字符，直至处理完全部字符或遇到空白
    for (auto it = s.begin(); it != s.end() && !isspace(*it); ++it)
        *it = toupper(*it); //将当前字符改写成大写形式
    cout << s << endl;
    return 0;
}
/*
Some string
SOME string
*/

迭代器的类型拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器类型
vector<int>::itertor it;//it能读写vector<int>对象的元素
string::itertor it2;//it2能读写string对象中的字符
vector<int>::const_itertor it3;//it3只能读，不能写vector<int>对象的元素
string::const_itertor it4;//it4只能读不能写string对象中的字符

迭代器三种不同含义：迭代器概念本书，容器定义的迭代器类型，某个迭代器对象
vector<int> v;
const vector<int> cv;
auto it1=v.begin();//it1对象类型是vector<int>::iterator
auto it2=cv.begin();//it2对象类型是vector<int>::const_iterator

解引用迭代器可以获得迭代器所指的对象
//example-3.4.1-.cpp
#include <iostream>
#include <vector>
using namespace std;
int main()
{
    string s("some string");
    if (s.begin() != s.end()) //确保s非空
    {
        auto it = s.begin(); //it表示s的第一个字符
        *it = toupper(*it);  //将当前字符改写成大写形式
    }
    cout << s << endl;
    //依次处理s的字符，直至处理完全部字符或遇到空白
    for (auto it = s.begin(); it != s.end() && !isspace(*it); ++it) //!=与<迭代器与下标的区别
        *it = toupper(*it);                                         //将当前字符改写成大写形式
    cout << s << endl;
    //依次处理text的元素，直至处理完全部元素或遇到为空的元素
    vector<string> text = {"Hello world"," ","Some string"};
    for (decltype(text.cbegin()) it = text.cbegin(); it != text.cend() && !it->empty(); ++it)
        cout << *it<< endl;//只读未写可以用cbegin和cend
    return 0;
}
/*
Some string
SOME string
Hello world

Some string
*/

3.4.2 迭代器运算

iter + n   迭代器加上一个整数仍得一个迭代器，
迭代器指示的新位置与原来相比向后移动了若干个元素

　
iter - n   迭代器减去一个整数仍得一个迭代器，
迭代器指示的新位置与原来相比向前移动了若干个元素
iter += n  迭代器加法的复合赋值语句
iter -= n  迭代器减法的复合赋值语句
iter1-iter2 两个迭代器之间的距离
>,>=,<,<=  关系运算符，迭代器所指容器位置的前后

//example-3.4.2-.cpp
#include <iostream>
#include <vector>
using namespace std;
int main()
{
    vector<string> text = {"Hello world", " ", "Some string", "Minrrww", "just for you"};
    //text必须是有序的
    //beg和end表示我们搜索范围
    auto beg = text.begin(), end = text.end();
    auto mid = text.begin() + (end - beg) / 2; //初始状态下的中间点
    //当还有元素尚未检查并且我们还没找到sought时执行循环
    string sought = "Minrrww";
    while (mid != end && *mid != sought)
    {
        if (sought < *mid)           //我们要找的元素在前半部分吗？
            end = mid;               //如果是，调整搜索范围使得忽略掉后半部分
        else                         //我们要找到元素在后半部分吗？
            beg = mid + 1;           //在mid之后寻找
        mid = beg + (end - beg) / 2; //新的中间点
    }
    cout << *++beg << endl;
    cout << *++mid << endl;
    cout << *++end << endl;
}
/*
Minrrww
Minrrww
Minrrww
*/

3.5 数组
数组是一种类似标准类型vector的数据结构
相似：数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问
不同：数组的大小确定不变，不能随意向数组中增加元素

3.5.1 定义和初始化内置数组
数组是一种符合类型
声明形如a[d]，a是数组的名字，d是数组的维度，说明数组中元素的个数，必须大于0
数组的维度，编译的时候维度应该是已知的
unsigned cnt=42;//不是常量表达式
constexpr unsigned sz=42;//常量表达式
int arr[10];//含有10个整数的数组
int *parr[sz];//含有42个整型指针的数组
//string bad[cnt];//错误：cnt不是常量表达式
string strs[get_size()];//当get_size是constexpr时正确；否则错误

数组的元素被默认初始化
函数内部定义内置数组，默认初始化数组含有未定义的值

定义数组时必须指定数组的类型，不能用auto关键字
数组元素应为对象，不存在引用的数组


显示初始化数组，可以忽略数组的维度
初始值的总数量应该比维度小
const unsigned sz=3;
int ia1[sz]={0,1,2};含有三个元素的数组，元素值分别是0,1，2
int a2[]={0,1,2};//维度是3的数组
int a3[5]={0,1,2};//等价于a3[]={0,1,2,0,0}
string a4[3]={"hi","bye"};//等价于a4[]={"hi","bye",""}
int a5[2]={0,1,2};//错误，初始值过多

字符数组的特殊性
字符串字面值 默认 结尾处还有一个空字符

char a1[]={'C','+',"+'};//列表初始化，没有空字符
char a2[]={'C','+',"+','\0'};//列表初始化，含显式的空字符
char a3[]="C++";//自动添加表示字符串结束的空字符
//const char a4[6]="Daniel";//错误，没有空间可存放空字符

数组不允许拷贝和赋值
不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值

理解复杂的数组声明
数组能存放大多数类型的对象
数组本身也是对象，允许定义数组的指针及数组的引用
int *ptrs[10];//ptrs是含有10个整型指针元素的数组
int &refs[10];//错误：不存在元素是引用得数组
int (*parray)[10]=&arr;//parray 指向一个含有10个整数的数组
int (&arrRef)[10]=arr;//arrRef引用一个含有10个整数的数组
int *(&arry)[10]=ptrs;//arry是数组的引用，该数组含有10个指针

要理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读

3.5.2 访问数组的元素
和vector和string一样，使用范围for语句或下标运算符来访问
数组下标类型：size_t，不是无符号类型，在cstddef头文件中定义

//example-3.5.2-.cpp
#include <iostream>

using namespace std;

int main()
{
    unsigned grade;
    unsigned scores[11] = {}; //11个分数段，全部初始化为0
    while (cin >> grade)             //读取成绩
    {
        if (grade <= 100)         //只处理有效成绩
            ++scores[grade / 10]; //将对应的分数段的计数器加1
    }
    for (unsigned s : scores) //对于scores中的每个计数值
        cout << s << " ";     //输出当前的计数值
    cout << endl;
    return 0;
}
/*
12 23 32 43 54 65 76 87 98 100 5
^Z
1 1 1 1 1 1 1 1 1 1 1
*/

检查下标的值
下标值范围0<=下标<size()

3.5.3 指针和数组
数组名为指向数组第一个元素的指针
使用数组名作为auto变量的初始值时，推断出的类型是指针而不是数组
    string nums[] = {"one", "two", "three"}; //数组的元素是string对象
    string *pstr1 = &nums[0];                //pstr1指向nums的第一个元素
    string *pstr2 = nums;                    //等价于*pstr2=&nums[0]
    cout << *pstr1 << " " << *pstr2 << endl; //输出pstr1,pstr2指向的对象
    cout << (pstr1 == pstr2) << endl;        //输出两个指针是否相等

    int ia1[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; //ia是一个含有10个整数的数组
    auto ia2(ia1);                              //ia2是一个整型指针，指向ia的第一个元素。等价于auto ia2(&ia[0])
    //ia2 = 43;                                 //错误：ia2是一个指针，不能用int值给指针赋值
    cout << ia1[5] << " " << *(ia2 + 5) << endl; //输出ia[5]和ia2+5指针指向的对象

使用decltype关键字，返回的类型是由10个整数够成的数组
    //ia3是一个含有10个整数的数组
    decltype(ia1) ia3 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    //ia3 = p;    //错误，不能用整型指针给数组赋值
    int i = 10;
    ia3[4] = i;                                  //正确：把i的值付给ia3的一个元素
    cout << ia1[4] << " " << *(ia3 + 4) << endl; //对比ia[4]和ia3+4指向的对象

指针也是迭代器
数组的指针和迭代器一样支持运算
    int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    int *ip = arr; //ip指向arr的第一个元素
    cout << *ip << " ";
    ++ip; //p指向arr[1];
    cout << *ip << endl;

尾后指针
    int *e1 = &arr[10]; //指向arr尾元素的下一个位置的指针
    cout << e1 << endl; //输出尾后指针
尾后指针不能解引用或递增操作

标准库函数begin和end
    int *beg = begin(ia1);                 //指向ia首元素的指针
    int *last = end(ia1);                  //指向ia尾元素的下一位置的指针
    cout << end(ia1) - begin(ia1) << endl; //输出尾后指针和首指针之间的距离

指针运算
包括：解引用，递增，比较，与整数相加，两个指针相见等
    constexpr size_t sz = 5;
    int arr1[sz] = {1, 2, 3, 4, 5};
    int *ip1 = arr1;                     //等价于int *ip1=&arr[0]
    int *ip2 = ip1 + 4;                  //ip2指向arr的尾元素arr[4]
    cout << *ip1 << " " << *ip2 << endl; //指针加法

    int *ip3 = arr1 + sz; //不能解引用
    //int *p2 = arr1 + 10; //错误，arr只有5个元素，p2的值未定义

两个指针相减的值时它们之间的距离
auto n = end(arr1) - begin(arr1); //n的值是5，也是arr中元素的数量
类型为ptrdiff_t的标准库类型，带符号的类型

遍历数组中的元素：
    int *b = arr1, *e = arr1 + sz;
    while (b < e)
    {
        cout << *b; //使用*b;
        ++b;
    }
    cout << endl;
解引用和指针运算的交互
    int ia[] = {0, 2, 4, 6, 8}; //含有5个整数的数组
    int last1 = *(ia + 4);      //相当于把ia[4]初始化给last
    int last2 = *ia + 4;        //相当于把ia[0]+4初始化给l
    cout << last1 << " " << last2 << endl;

下标和指针
内置的下标运算符所用的索引值不是无符号类型,与vector和string不同
    int a = ia[2];  //ia转换成指向数组首元素的指针
                    //ia[2]得到(ia+2)所指的元素
    int *ap = ia;   //ap指向ia的首元素
    a = *(ap + 2);  //等价于i=ia[2]
    ap = &ia[2];    //ap指向索引为2的元素
    int j = ap[1];  //ap[1]等价于*(p+1),就是ia[3]表示的那个元素
    int k = ap[-2]; //ap[-2]等价于*(ap-2),就是ia[0]表示的那个元素
    cout << a << " " << j << " " << k << endl;

3.5.4 C风格字符串
C风格字符串（C-style character string）
尽量不用C风格字符串，不方便，极易引发程序漏洞
C风格字符串 不是一种类型
1.字符串字面值 此字符串存放字符数组并以空字符结束（null terminated）
2.C标准库String函数
定义在cstring头文件中
strlen(p)      返回p的长度，空字符不计算在内
strcmp(p1,p2)  比较p1和p2的相等性。如果p1==p2，返回0；
               如果p1>p2，返回一个正值；如果p1<p2，返回一个负值
strcat(p1,p2)  将p2附加到p1之后，返回p1
strcpy(p1,p2)  将p2拷贝给p1,返回p1
上述函数不负责验证其字符串参数

此类函数的指针必须指向以空字符作为结束的数组
char ca[]={'C','+','+'};//不以空字符结束
cout<<strlen(ca)<<endl;//错误，ca没有以空字符结束

比较字符串
string s1="A string example";
string s2="A different string";
if(s1<s2)//false:s2<s1
C风格字符串比较，实际比较的将是指针而非字符串本身
const char ca1[]="A string example";
const char ca2[]="A different string";
if(ca1<ca2)//未定义的：试图比较两个无关地址
调用strcmp函数，两个字符串相等，strcmp返回0；前面字符串较大，返回正值
后面字符串较大，返回负值
if(strcmp(ca1,ca2)<0)//和if(s1<s2)效果一样

目标字符串的大小由调用者指定
//eaample-3.5.4-.cpp
#include <iostream>
#include <cstring>
#include <vector>
using namespace std;

int main()
{
    int n = 0;
    string s1 = "A string example"; //声明并定义一个string类型s1
    cout << ++n;                    //1
    //用下标输出s1每一个字符
    for (decltype(s1.size()) i = 0; i != s1.size(); i++)
    {
        s1[i] = char(s1[i] + 1); //使用下标修改字符
        cout << s1[i];           //用下标输出s1每一个字符
    }
    cout << endl;

    vector<char> vc(s1.begin(), s1.end());
    //用下标输出vc每一个字符
    for (decltype(vc.size()) i = 0; i != vc.size(); i++)
    {
        vc[i] = char(vc[i] + 1); //使用下标修改字符
        cout << vc[i];           //用下标输出s1每一个字符
    }
    cout << endl;

    //范文for循环修改字符
    for (auto &st1 : s1)
        st1 = st1 + 1;
    cout << ++n; //2
    //用迭代器输出重s1新赋值后d的每一个字符
    for (auto i = s1.begin(); i != s1.end(); i++)
        cout << *i;
    cout << endl;

    string s2 = "A different string";    //声明并定义一个string类型s2
    cout << ++n;                         //3
    cout << s1 << " " << s2 << endl;     //用输出流连接s1,s2
    cout << ++n;                         //4
    cout << (s1 < s2 ? s1 : s2) << endl; //比较s1,s2大小,因s1>s2,输出s2
    string largeStr = s1 + " " + s2;     //string对象相加
    cout << ++n;                         //5
    cout << largeStr << endl;

    //指针不能指向表达式和字面值，但是可以指向字符串字面值，把字符串字面值看着字符数组
    char *const cap1 = "A string example"; //定义一个指针cap1，指向字符串字面值
    //不能改变cap1的值，只能看着指向常量字符数组
    cout << ++n; //6
    //用下标输出cap1每一个字符，用sizeof运算符不能全部输出，用strlen
    //strlen不包括字符串末尾的空字符'\0'
    for (decltype(strlen(cap1)) i = 0; i != strlen(cap1); i++)
        cout << cap1[i];
    /*不支持范围for循环，迭代器
    for (auto st1 : cap1)
        cout << st1;
    cout << endl;
    for (auto i = begin(cap1); i != end(cap1); i++)
        cout << cap1[i];
    cout << endl;
    */
    cout << endl;
    cout << ++n;                         //7
    cout << cap1 << endl;                //直接输出指针，输出字符数组
    cout << ++n;                         //
    cout << *cap1 << endl;               //输出解引用，输出指针指向的首字符
    cout << ++n;                         //9
    cout << cap1 + 1 << endl;            //支持指针运算，输出还是字符数组
    cout << ++n << endl;                 //10
    cout << cap1 + strlen(cap1) << endl; //输出最后一个字符，即'\0'
    cout << ++n << endl;                 //11
    cout << cap1 + 17 << endl;           //超范围输出看紧邻定义的常量，字符串字面值在同一内存区域？
    cout << ++n << endl;                 //12
    cout << *(cap1 + 17) << endl;        //超范围输出指针解引用？不知道输出为空？

    char *const cap2 = "A different string"; //定义一个指针cap2，指向字符串字面值
    char largetCap[37];                      //定义一个字符数组，它的大小会影响输出结果
    strcpy(largetCap, cap1);                 //将cap1拷贝给largetCap
    strcat(largetCap, " ");                  //将largetCap末尾加上一个空格
    strcat(largetCap, cap2);                 //将cap2连接到largetCap后面
    cout << ++n;                             //13
    cout << largetCap << endl;               //largetCap的长度影响输出结果
    cout << ++n;                             //14
    //比较指针，不管怎么理解编译器，只能说无意义
    cout << (cap1 < cap2 ? cap1 : cap2) << endl;
    cout << ++n; //15
    //比较字符串大小，'s'>'d',所以cap1指向的数组大于cap2指向的数组
    //strcmp(cap1,cap2)返回正值，条件为假，输出cap2
    cout << (strcmp(cap1, cap2) < 0 ? cap1 : cap2) << endl;

    char ca1[] = "A string example"; //声明并定义一个字符数组ca1
    cout << ++n;                     //16
    //用下标输出s1每一个字符
    for (decltype(strlen(ca1)) i = 0; i != strlen(ca1); i++)
        cout << ca1[i];
    cout << endl;

    //范文for循环为每一字符赋值
    for (auto &st1 : ca1)
        st1 = st1 + 1;
    cout << ++n; //17
    //用迭代器输出重s1新赋值后d的每一个字符
    for (auto i = begin(ca1); i != end(ca1); i++)
        cout << *i;
    cout << endl;

    const char ca2[] = "A different string"; //声明并定义一个字符数组ca2
    char largetCh[36];                       //定义一个空字符数组
    strcpy(largetCh, ca1);                   //将ca1拷贝给largetCh
    strcat(largetCh, " ");                   //将largetCh末尾加上一个空格
    strcat(largetCh, ca2);                   //将ca2连接到largetCh后面
    cout << ++n;                             //18
    cout << largetCh << endl;
    cout << ++n;                               //19
    cout << ca1 + 7 << " " << ca2 + 7 << endl; //支持指针运算
    cout << ++n;                               //20
    //比较指针，比较两个不同对象的指针无意义
    cout << (ca1 > ca2 ? ca1 : ca2) << endl;
    cout << ++n; //21
    //比较字符串大小，'B'>'A',所以cap1指向的数组大于cap2指向的数组
    //strcmp(cap1,cap2)返回正值，条件为假，输出cap2
    cout << (strcmp(ca1, ca2) < 0 ? ca1 : ca2) << endl;
    return 0;
}
/*输出结果很奇怪，所以尽量不用C风格字符串
1B!tusjoh!fybnqmf
C"uvtkpi"gzcorng
2C"uvtkpi"gzcorng
3C"uvtkpi"gzcorng A different string
4A different string
5C"uvtkpi"gzcorng A different string
6A string example
7A string example
8A
9 string example
10

11
A different string
12

13A string example A different string
14A string example
15A different string
16A string example
17B!tusjoh!fybnqmf
18B!tusjoh!fybnqmf A different string
19h!fybnqmf rent string
20B!tusjoh!fybnqmf
21A different string
*/

3.5.5 与旧代码的接口
混用string对象和C风格字符串
允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值
在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象
（不能两个对象都是）；在string对象的复合赋值运算中允许使用以空字符结束的字
符数组作为右侧的运算对象。

不能将string对象直接赋值给指向字符的指针，需要通过c_str的成员函数
char *str=s;//错误：不能用string对象初始化char*
const char *str=s.c_str();//正确

使用数组初始化vector对象
int int_arr[]={0,1,2,3,4,5};
vector<int> ivec(begin(int_arr),end(int_arr));//数组的全部初始化vector对象
vector<int> subVec(int_arr+1,int_arr+4);//数组的部分初始化vector对象


3.6 多维数组
多维数组是数组的数组
理解多维数组，按照由内而外的顺序阅读
int ia[3][4];//大小为3的数组，每个元素是含有4个整数的数组

多维数组的初始化
ia[3][4]={
    {0,1,2,3},
    {4,5,6,7},
    {8,9,10,11}
};
等同于
ia[3][4]={0,1,2,3,4,5,6,7,8,9,10,11};

显式地初始化每行的首元素
ia[3][4]={{0}, {4},{8}};
与下面的初始化完全不同
ia[3][4]={0,4,8};

显式地初始化第一行
ia[3][4]={0,1,2,4};

多维数组的下标引用
ia[2][3] = arr[8][9][10]; //赋值
int (&row)[4]=ia[1]//把引用row绑定到ia的第二个数组上

指针和多维数组

    //p是指针，指向维度是4的数组，数组的元素类型是整数
    //p指向第一层数组ia[],p=&ia[]
    int(*p)[4] = ia;//p指向含有4个整数的数组,用ia数组的首地址初始化auto p=ia;
    p = &ia[2];//p指向ia的尾元素
    cout << *(*p) << endl;

    //指针遍历多维数组
    for (int (*p)[4] = ia; p != ia + (end(ia) - begin(ia)); p++)
    {
        for (auto q = *p; q != *p + (end(*p) - begin(*p)); q++) //数组迭代器距离的数据类型ptrdiff_t
        {
            cout << *q<< " ";
        }
    }
    cout << endl;

    类型别名简化多维数组的指针
    using int_array = int[4];//新标准下类型别名声明
    typedef int intArray;//等价的typedef 类型别名声明
    for (int_array *p = ia; p != ia + (end(ia) - begin(ia)); p++)
    {
        for (intArray *q = *p; q != *p + (end(*p) - begin(*p)); q++) //数组迭代器距离的数据类型ptrdiff_t
        {
            cout << *q<< " ";
        }
    }
    cout << endl;


//eaample-3.6-.cpp
#include <iostream>
using namespace std;

int main()
{
    //大小为3的数组，每个元素是含有4个整数的数组
    int ia[3][4] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
    //大小为10的数组，每个元素都是大小为20的数组
    //这些数组的元素是含有30个整数的数组
    int arr[10][20][30] = {11};                 //将所有元素初始化为0
    cout << ia[2][3] << endl;                   //下标输出
    cout << *(*(ia + 2) + 3) << endl;           //解引用输出
    cout << *(end(*(end(ia) - 1)) - 1) << endl; //迭代器解引用
    ia[2][3] = arr[0][0][0];                    //赋值
    cout << ia[2][3] << endl;                   //下标输出
    cout << *(*(ia + 2) + 3) << endl;           //解引用输出
    cout << *(end(*(end(ia) - 1)) - 1) << endl; //迭代器解引用
    //把引用row绑定到ia的第二个数组上,引用的是一个数组名(指针变量)
    int(&row)[4] = ia[1];
    cout << *row << endl;
    //迭代器给多维数组赋值

    for (auto i = begin(ia); i != end(ia); i++)
    {
        for (auto j = begin(*i); j != end(*i); j++)
        {
            *j = *j * *j; //赋值
            cout << *j << " ";
        }
    }
    cout << endl;

    //下标遍历多维数组
    for (decltype(end(ia) - begin(ia)) i = 0; i != end(ia) - begin(ia); i++)
    {
        for (ptrdiff_t j = 0; j != end(ia[i]) - begin(ia[i]); j++) //数组迭代器距离的数据类型ptrdiff_t
        {
            cout << ia[i][j] << " ";
        }
    }
    cout << endl;

    //范围for语句遍历多维数组
    //改变数组元素的值，row、col需要定义为引用
    //不改变数组元素的值，row需要定义为引用，避免数组被自动转成指针
    //如果row不定义为引用，row会被认为是指向首元素int *类型的指针
    //内循环就不合法了
    for (const auto &row : ia)
        for (auto col : row)
            cout << col << " ";
    cout << endl;

    //p是指针，指向维度是4的数组，数组的元素类型是整数
    //p指向第一层数组ia[],p=&ia[]
    //int(*p)[4] = ia; //p指向含有4个整数的数组,用ia数组的首地址初始化auto p=ia;
    //p = &ia[2];//p指向ia的尾元素
    //cout << *(*p) << endl;
    //指针遍历多维数组
    for (int(*p)[4] = ia; p != ia + (end(ia) - begin(ia)); p++)
    {
        for (auto q = *p; q != *p + (end(*p) - begin(*p)); q++) //数组迭代器距离的数据类型ptrdiff_t
        {
            cout << *q << " ";
        }
    }
    cout << endl;

    //类型别名简化多维数组的指针
    using int_array = int[4]; //新标准下类型别名声明
    typedef int intArray;     //等价的typedef 类型别名声明
    for (int_array *p = ia; p != ia + (end(ia) - begin(ia)); p++)
    {
        for (intArray *q = *p; q != *p + (end(*p) - begin(*p)); q++) //数组迭代器距离的数据类型ptrdiff_t
        {
            cout << *q << " ";
        }
    }
    cout << endl;

    return 0;
}
/*
11
11
11
11
11
11
4
0 1 4 9 16 25 36 49 64 81 100 121
0 1 4 9 16 25 36 49 64 81 100 121
0 1 4 9 16 25 36 49 64 81 100 121
0 1 4 9 16 25 36 49 64 81 100 121
0 1 4 9 16 25 36 49 64 81 100 121
*/
