# primer C++ 中文版 第五版

任何常用的编程语言都具备一组公共的语法特征，不同语言仅在特征的细节上有所区别。要想学习并掌握一种编程语言，理解其语法特征的实现细节是第一步。最基本的特征包括：

- 整型、字符型等内置类型
- 变量，用来为对象命名
- 表达式和语句，用于操纵上述数据类型的具体值
- if或while等控制结构，这些结构允许我们有选择地执行一些语句或者重复地执行一些语句
- 函数，用于定义可供随时调用的计算单元

大多数编程语言通过两种方式来进一步补充其基本特征：一是赋予程序员自定义数据类型的权利，从而实现对语言的扩展;二是将一些有用的功能封装成库函数提供给程序员。

与大多数编程语言一样，CH的对象类型决定了能对该对象进行的操作，一条表达式是否合法依赖于其中参与运算的对象的类型。一些语言，如Smalltalk和Python等，在程序运行时检查数据类型;与之相反，C++是一种静态数据类型语言，它的类型检查发生在编译时。因此，编译器必须知道程序中每一个变量对应的数据类型。

C++提供了一组内置数据类型、相应的运算符以及为数不多的几种程序流控制语句，这些元素共同构成了C++语言的基本形态。以这些元素为基础，我们可以编写出规模庞大、结构复杂、用于解决实际问题的软件系统。仅就C++的基本形态来说，它是一种简单的编程语言，其强大的能力显示于它对程序员自定义数据结构的支持。这种支持作用巨大，显而易见的一个事实是，C++语言的缔造者无须洞悉所有程序员的要求，而程序员恰好可以通过自主定义新的数据结构来使语言满足他们各自的需求。

C++中最重要的语法特征应该就是类了，通过它，程序员可以定义自己的数据类型。
为了与C++的内置类型区别开来，它们通常被称为“类类型(class type)”。在一些编程语言中，程序员自定义的新类型仅能包含数据成员;另外一些语言，比如C++，则允许新类型中既包含数据成员，也包含函数成员。C++语言主要的一个设计目标就是让程序员自定义的数据类型像内置类型一样好用。基于此，标准C++库实现了丰富的类和函数。

本书第1部分的主题是学习C++语言的基础知识，这也是掌握C++语言的第一步。第2章详述内置类型，并初步介绍了自定义数据类型的方法。第3章介绍了两种最基本的数据类型：字符串和向量。C++和许多编程语言所共有的一种底层数据结构--数组也在本章有所提及。接下来，第4~6章依次介绍了表达式、语句和函数。作为第】部分的最后章，第7章描述了如何构建我们自己的类，完成这一任务需要综合运用之前各章所介绍的知识。

## 第二章 变量和基本类型

数据类型是程序的基础：它告诉我们数据的意义以及我们能在数据上执行的操作。

C++语言支持广泛的数据类型。它定义了几种基本内置类型(如字符、整型、浮点数等)，同时也为程序员提供了自定义数据类型的机制。基于此，C++标准库定义了一些更加复杂的数据类型，比如可变长字符串和向量等。本章将主要讲述内置类型，并带领大家初步了解C++语言是如何支持更复杂数据类型的。

数据类型决定了程序中数据和操作的意义。如下所示的语句是一个简单示例：

```cpp
i= i + j;
```

其含义依赖于i和j的数据类型。如果i和j都是整型数，那么这条语句执行的就是最普通的加法运算。然而，如果i和j是Sales item类型的数据(参见1.5.1节，第17页)，则上述语句把这两个对象的成分相加。

### 2.1 基本内置类型

C++定义了一套包括算术类型(arithmetictype)和空类型(void)在内的基本数据类型。其中算术类型包含了字符、整型数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合，例如最常见的是，当函数不返回任何值时使用空类型作为返回类型。

#### 2.1.1 算术类型

算术类型分为两类：整型(integral type，包括字符和布尔类型在内)和浮点型。

算术类型的尺寸(也就是该类型数据所占的比特数)在不同机器上有所差别。表2.1列出了C++标准规定的尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸。某一类型所占的比特数不同，它所能表示的数据范围也不一样。

表2.1：C++：算术类型
| 类型        | 含义           | 最小尺寸     |
| ----------- | -------------- | ------------ |
| bool        | 布尔类型       | 未定义       |
| char        | 字符           | 8位          |
| wchar_t     | 宽字符         | 16位         |
| char16_t    | Unicode字符    | 16位         |
| char32_t    | Unicode字符    | 32位         |
| short       | 短整型         | 16位         |
| int         | 整型           | 16位         |
| long        | 长整型         | 32位         |
| long long   | 长整型         | 64位         |
| float       | 单精度浮点数   | 6位有效数字  |
| double      | 双精度浮点数   | 10位有效数字 |
| long double | 扩展精度浮点数 | 10位有效数字 |

布尔类型(bool)的取值是真(true)或者假(false)。

C++提供了几种字符类型，其中多数支持国际化。基本的字符类型是char，一个char的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个char的大小和一个机器字节一样。

其他字符类型用于扩展字符集，如wchar_t，char16_t，char32_t.wchar_t类型用于确保可以存放机器最大扩展字符集中的任意一个字符，类型char16_t和char32 t则为Unicode字符集服务(Unicode是用于表示所有自然语言中字符的标准)。

除字符和布尔类型之外，其他整型用于表示(可能)不同尺寸的整数。C++语言规定个int至少和一个short一样大，一个1ong至少和一个int一样大，一个long long至少和一个long一样大。其中，数据类型1ong long是在C++11中新定义的。

> **内置类型的机器实现**
>
> 计算机以比特序列存储数据，每个比特非0即1，例如：
> 00011011011100010110010000111011...
> 大多数计算机以2的整数次幕个比特作为块来处理内存，可寻址的最小内存块称为“字，节(byte)"，存储的基本单元称为“字(word)”，它通常由几个字节组成。在C++语言中，一个字节要至少能容纳机器基本字符集中的字符。大多数机器的字节由8比特构成，字则由32或64比特构成，也就是4或8字节。
> 大多数计算机将内存中的每个字节与一个数字(被称为“地址(address)”)关联起来，在一个字节为8比特、字为32比特的机器上，我们可能看到一个字的内存区域如下所示：
> | 736424 | 0   | 0   | 1   | 1   | 1   | 0   | 1   | 1   |
> | ------ | --- | --- | --- | --- | --- | --- | --- | --- |
> | 736425 | 0   | 0   | 0   | 1   | 1   | 0   | 1   | 1   |
> | 736426 | 0   | 1   | 1   | 1   | 0   | 0   | 0   | 1   |
> | 736427 | 0   | 1   | 1   | 0   | 0   | 1   | 0   | 0   |
> 其中，左侧是字节的地址，右侧是字节中8比特的具体内容。
> 我们能够使用某个地址来表示从这个地址开始的大小不同的比特串，例如，我们可能会说地址736424的那个字或者地址736427的那个字节。为了赋予内存中某个地址明确的含义，必须首先知道存储在该地址的数据的类型。类型决定了数据所占的比特数以及该如何解释这些比特的内容。
> 如果位置736424处的对象类型是float，并且该机器中float以32比特存储，那么我们就能知道这个对象的内容占满了整个字。这个float数的实际值依赖于该机器是如何存储浮点数的。或者如果位置736424处的对象类型是unsigned char，并且该机器使用ISO-Latin-1字符集，则该位置处的字节表示一个分号。

浮点型可表示单精度、双精度和扩展精度值。C1+标准指定了一个浮点数有效位数的最小值，然而大多数编译器都实现了更高的精度。通常，float以1个字(32比特)来表示，double 以2个字(64比特)来表示，long double 以3或4个字(96或128比特)来表示。一般来说，类型float和double分别有7和16个有效位;类型1ong double则常常被用于有特殊浮点需求的硬件，它的具体实现不同，精度也各不相同。

##### 带符号类型和不带符号类型

除去布尔型和扩展的字符型之外，其他整型可以划分为带符号的(signed)和无符号，的(unsigned)两种。带符号类型可以表示正数、负数或0，无符号类型则仅能表示大于等于0的值。

类型int，short，long和long 1ong都是带符号的，通过在这些类型名前添加unsigned 就可以得到无符号类型，例如unsigned long。类型unsigned int可以缩写为unsigned。

与其他整型不同，字符型被分为了三种：char，signed char和 unsigned char.特别需要注意的是：类型char和类型signed char并不一样。尽管字符型有三种，但是字符的表现形式却只有两种：带符号的和无符号的。类型char实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。

无符号类型中所有比特都用来存储值，例如，8比特的unsigned char可以表示0至255区间内的值。

C++标准并没有规定带符号类型应如何表示，但是约定了在表示范围内正值和负值的量应该平衡。因此，8比特的signed char理论上应该可以表示-127至127区间内的值，大多数现代计算机将实际的表示范围定为-128至127。

> **建议：如何选择类型**
>
> 和C语言一样，C1+的设计准则之一也是尽可能地接近硬件。C++的算术类型必须，满足各种硬件特质，所以它们常常显得繁杂而令人不知所措。事实上，大多数程序员能，够(也应该)对数据类型的使用做出限定从而简化选择的过程。以下是选择类型的一些经验准则：
>
> - 当明确知晓数值不可能为负时，选用无符号类型。
> - 使用int执行整数运算。在实际应用中，short常常显得太小而long一般和int有一样的尺寸。如果你的数值超过了int的表示范围，选用long long。
> - 在算术表达式中不要使用char或bool，只有在存放字符或布尔值时才使用它，们。因为类型char在一些机器上是有符号的，而在另一些机器上又是无符号的，所以如果使用char进行运算特别容易出问题。如果你需要使用一个不大的整数，那么明确指定它的类型是signed char或者unsigned char。
> - 执行浮点数运算选用double，这是因为float通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。long double提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视，

#### 2.1.2 类型转换

对象的类型定义了对象能包含的数据和能参与的运算，其中一种运算被大多数类型支持，就是将对象从一种给定的类型转换(convert)为另一种相关类型。

当在程序的某处我们使用了一种类型而其实对象应该取另一种类型时，程序会自动进行类型转换，在4.11节(第141页)中我们将对类型转换做更详细的介绍。此处，有必要说明当给某种类型的对象强行赋了另一种类型的值时，到底会发生什么。

当我们像下面这样把一种算术类型的值赋给另外一种类型时：

```cpp
bool b = 42;//b为真
int i = b;//i的值为1
i= 3.14;//i的值为3
double pi = i;//pi的值为3.0
unsigned char c=-1;//假设char 占8比特，c的值为255
signed char c2 = 256;//假设char 占8比特，c2的值是未定义的
```

类型所能表示的值的范围决定了转换的过程：当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为0则结果为false，否则结果为true。

- 当我们把一个布尔值赋给非布尔类型时，初始值为false则结果为0，初始值为true则结果为1。
- 当我们把一个浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。
- 当我们把一个整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。
- 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如，8比特大小的unsigned char可以表示0至255区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对256取模后所得的余数。因此，把-1赋给8比特大小的unsigned char所得的结果是255。
- 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的(undefined)。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据

> **建议：避免无法预知和依赖于实现环境的行为**
> 无法预知的行为源于编译器无须(有时是不能)检测的错误。即使代码编译通过了，如果程序执行了一条未定义的表达式，仍有可能产生错误。
> 不幸的是，在某些情况和/或某些编译器下，含有无法预知行为的程序也能正确执行。但是我们却无法保证同样一个程序在别的编译器下能正常工作，甚至已经编译通过的代，码再次执行也可能会出错。此外，也不能认为这样的程序对一组输入有效，对另一组输入就一定有效。
> 程序也应该尽量避免依赖于实现环境的行为。如果我们把int的尺寸看成是一个确定不变的已知值，那么这样的程序就称作不可移植的(nonportable)。当程序移植到别，的机器上后，依赖于实现环境的程序就可能发生错误。要从过去的代码中定位这类错误，可不是一件轻松愉快的工作。

当在程序的某处使用了一种算术类型的值而其实所需的是另一种类型的值时，编译器同样会执行上述的类型转换。例如，如果我们使用了一个非布尔值作为条件(参见1.4.1节，第10页)，那么它会被自动地转换成布尔值，这一做法和把非布尔值赋给布尔变量时的操作完全一样：

```cpp
int i 42;
if(i)//if条件的值将为true
  i= 0;
```

如果i的值为0，则条件的值为false;i的所有其他取值(非0)都将使条件为true.

以此类推，如果我们把一个布尔值用在算术表达式里，则它的取值非0即1，所以一般不宜在算术表达式里使用布尔值。

##### 含有无符号类型的表达式

尽管我们不会故意给无符号对象赋一个负值，却可能(特别容易)写出这么做的代码。
例如，当一个算术表达式中既有无符号数又有int值时，那个int值就会转换成无符号数。把int转换成无符号数的过程和把int直接赋给无符号变量一样：

```cpp
unsigned u = 10;
int i=-42;
std::cout << i + 1 << std::endl;//输-84
std::cout << u + i << std::endl;//如果int 占32位，输出4294967264
```

在第一个输出表达式里，两个(负)整数相加并得到了期望的结果。在第二个输出表达式里，相加前首先把整数-42转换成无符号数。把负数转换成无符号数类似于直接给无符号数赋一个负值，结果等于这个负数加上无符号数的模。

当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不能是一个负值：

```cpp
unsigned ul = 42，u2 = 10;
std::cout << ul-u2 << std::endl;//正确：输出 32
std::cout << u2-ul << std::endl;//正确：不过，结果是取模后的值
```

无符号数不会小于0这一事实同样关系到循环的写法。例如，在1.4.1节的练习(第11页)中需要写一个循环，通过控制变量递减的方式把从10到0的数字降序输出。这个循环可能类似于下面的形式：

```cpp
for(int i= 10;i >= 0;--i)
  std::cout << i << std::endl;
```

可能你会觉得反正也不打算输出负数，可以用无符号数来重写这个循环。然而，这个不经意的改变却意味着死循环：

```cpp
//错误：变量u永远也不会小于0，循环条件一直成立
for(unsigned u= 10;u >= 0;--u)
  std::cout << u << std：：endl;
```

来看看当u等于0时发生了什么，这次选代输出0，然后继续执行for语句里的表达式。表达式-u从u当中减去1，得到的结果-1并不满足无符号数的要求，此时像所有表示范，围之外的其他数字一样，-1被自动地转换成一个合法的无符号数。假设int类型占32位，则当u等于0时，--u的结果将会是4294967295。

一种解决的办法是，用while语句来代替for语句，因为前者让我们能够在输出变量之前(而非之后)先减去1：

```cpp
unsigned u= 11;//确定要输出的最大数，从比它大1的数开始
while(u > 0){}
  --u;//先减1，这样最后一次选代时就会输出0
  std::cout << u << std::endl;
}
```

改写后的循环先执行对循环控制变量减1的操作，这样最后一次选代时，进入循环的u值为1.此时将其减1，则这次选代输出的数就是0：下一次再检验循环条件时，u的值等于0而无法再进入循环。因为我们要先做减1的操作，所以初始化u的值应该比要输出的最大值大1，这里，u初始化为11，输出的最大数是10。

> **提示：切勿混用带符号类型和无符号类型**
> 如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号数。例如，在一个形如a*b的式子中，如果a=-1，b= 1，而且a和b都是int，则表达式的值显然为-1。然而，如果a是int，而b是unsigned，则结果须视在当前机器上int所占位数而定。在我们的环境里，结果是4294967295。

#### 2.1.3 字面值常量

个形如42的值被称作字面值常量（literal），这样的值一望而知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

##### 整型和浮点型字面值

我们可以将整型字面值写作十进制数、八进制数或十六进制数的形式。以0开头的整数代表八进制数，以0x或0x开头的代表十六进制数。例如，我们能用下面的任意一种形式来表示数值20：

```text
20 /*十进制*/    024 *八进制*/    0x14 /*十六进制*/
```

整型字面值具体的数据类型由它的值和符号决定。默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号的也可能是无符号的。十进制字面值的类型是int，long 和long long中尺寸最小的那个（例如，三者当中最小是int），当然前提是这种类型要能容纳下当前的值。八进制和十六进制字面值的类型是能容纳其数值的int、unsigned int，long，unsigned long，long long unsigned long long中的尺寸最小者。如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误。类型short没有对应的字面值。在表2.2（第37页）中，我们将以后缀代表相应的字面值类型。

尽管整型字面值可以存储在带符号数据类型中，但严格来说，十进制字面值不会是负数。如果我们使用了一个形如-42的负十进制字面值，那个负号并不在字面值之内，它的作用仅仅是对字面值取负值而已。

浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用E或e标识：

```text
3.14159  3.14159E0  0.  0e0  .001
```

默认的，浮点型字面值是一个double，我们可以使用表2.2（第37页）中的后缀来表示其他浮点型。

##### 字符和字符串字面值

由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串型字面值。

```cpp
'a'//字符字面值
"Hello World!"//字符串字面值
```

字符串字面值的类型实际上是由常量字符构成的数组（array），该类型将在3.5.4节（第109页）介绍。编译器在每个字符串的结尾处添加一个空字符（'\0'），因此，字符串字面值的实际长度要比它的内容多1。例如，字面值"A'表示的就是单独的字符A，而字符串"A"则代表了一个字符的数组，该数组包含两个字符：一个是字母A、另一个是空字符。

如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。当书写的字符串字面值比较长，写在一行里不太合适时，就可以采取分开书写的方式：

```cpp
//分多行书写的字符串字面值
std::cout <<"a really，really long string literal"
"that spans two lines"<< std::endl;
```

##### 转义序列

有两类字符程序员不能直接使用：一类是不可打印（nonprintable）的字符，如退格或其他控制字符，因为它们没有可视的图符;另一类是在CH+语言中有特殊含义的字符（单引号、双引号、问号、反斜线）。在这些情况下需要用到转义序列（escape sequence），转义序列均以反斜线作为开始，C1+语言规定的转义序列包括：

| 字符常量形式 | 含义       | 十六进制 | 十六进制表示       | 八进制表示       |
| ------------ | ---------- | -------- | ------------------ | ---------------- |
| \a           | 响铃       | 07       | char(0x07) '\x07'  | char(007) '\007' |
| \n           | 换行       | 0A       | char(0x0A) '\x0A'  | char(012) '\012' |
| \t           | 水平制表符 | 09       | char(0x09)  '\x09' | char(011) '\011' |
| \v           | 垂直制表符 | 0B       | char(0x0B)  '\x0B' | char(013) '\013' |
| \b           | 退格       | 08       | char(0x08)  '\x08' | char(010) '\010' |
| \r           | 回车       | 0D       | char(0x0D)  '\x0D' | char(015) '\015' |
| \f           | 换页       | 0C       | char(0x0C)  '\x0C' | char(014) '\014' |
| \\\          | 字符'\\'   | 5C       | char(0x5C)  '\x5C' | char(134) '\134' |
| \"           | 双引号     | 22       | char(0x22)  '\x22' | char(042) '\042' |
| \'           | 单引号     | 27       | char(0x27)  '\x27' | char(047) '\047' |

在程序中，上述转义序列被当作一个字符使用：

```cpp
std::cout <<'\n';//转到新一行
std::cout <<"\tHi!\n";//输出一个制表符，输出"Hi"，转到新一行
```

我们也可以使用泛化的转义序列，其形式是\x后紧跟1个或多个十六进制数字，或者\后紧跟1个、2个或3个八进制数字，其中数字部分表示的是字符对应的数值。假设使用的是Latin-1字符集，以下是一些示例：

我们可以像使用普通字符那样使用C++语言定义的转义序列：

```cpp
std::cout <<"Hi \x4d0\115!\n";//输出Hi MOM！，转到新一行
std::cout <<'\115'<<'\n';//输出M，转到新一行
```

注意，如果反斜线、后面跟着的八进制数字超过3个，只有前3个数字与\构成转义序列。例如，"\1234"表示2个字符，即八进制数123对应的字符以及字符4。相反，\x要用到后面跟着的所有数字，例如，"\x1234"表示一个16位的字符，该字符由这4个十六进制数所对应的比特唯一确定。因为大多数机器的char型数据占8位，所以上面这个例子可能会报错。一般来说，超过8位的十六进制字符都是与表2.2中某个前缀作为开头的扩展字符集一起使用的。

##### 指定字面值的类型

通过添加如表2.2中所列的前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。

```text
L'a"     //宽字符型字面值，类型是wchar_t
u8"hi!"  //utf-8字符串字面值（utf-8用8位编码一个Unicode字符）
42ULL    //无符号整型字面值，奥型是unsigned long long
1E-3F    //单精度浮点型字面值，类型是float
3.14159L //扩展精度浮点型字面值，类型是long double
```

> **Best Praetiees**
> 当使用一个长整型字面值时，请使用大写字母L来标记，因为小写字母1和数字1太容易混淆了。

表2.2：指定字面值的类型
| 前缀 | 含义          | 类型     |
| ---- | ------------- | -------- |
| u    | Unicode16字符 | char16_t |
| U    | Unicode32字符 | char32_t |
| L    | 宽字符        | wchar_t  |
| u8   | UTF-8         | char     |

| 整型字面值后缀 | 整型字面值最小匹配类型 | 浮点字面值后缀 | 浮点字面值最小匹配类型 |
| -------------- | ---------------------- | -------------- | ---------------------- |
| u or U         | unsigned               | f or F         | float                  |
| l or L         | long                   | l or L         | Long double            |
| ll or LL       | long long              |                |                        |

对于一个整型字面值来说，我们能分别指定它是否带符号以及占用多少空间。如果后级中有U，则该字面值属于无符号类型，也就是说，以U为后级的十进制数、八进制数或十六进制数都将从unsigned int，unsigned long 和unsigned long long 中选择能匹配的空间最小的一个作为其数据类型。如果后缀中有L，则字面值的类型至少是1ong；如果后缀中有LL，则字面值的类型将是long long和unsigned long long中的一种。显然我们可以将U与L或LL合在一起使用。例如，以UL为后缀的字面值的数据类型将根据具体数值情况或者取unsigned long，或者取unsigned long long.

##### 布尔和指针字面值

true和false是布尔类型的字面值：

```cpp
bool test = false;
```

nullptr是指针字面值，2.3.2节（第47页）将有更多关于指针和指针字面值的介绍。

| 字面值名称 | 字面值例子 |
| ---------- | ---------- |
| bool       | true false |
| 指针       | nullptr    |

### 2.2 变量

变量提供一个具名的、可供程序操作的存储空间。C++中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。对CH程序员来说，“变量（variable）”和“对象（object）”一般可以互换使用。

#### 2.2.1 变量定义

##### 初始值

- 初始化：创建变量并赋初值
- 赋值：擦出当前值，以新值替代

##### 列表初始化

- 一组用花括号括起来的初始值

##### 默认初始化

- 定义于任何函数体外地变量被初始化为0
- 定义在函数体内部的内置类型变量将不被初始化

#### 2.2.2 声明变量和定义的关系

- 声明非定义

```cpp
extern int i;//extern 只声明不赋值
```

- 声明并定义

```cpp
int j;//声明并定义j
```

- 定义非声明

```cpp
extern double pi=3.1416;//显式初始化的声明不在是声明，是定义
```

- 函数体内部初始化extern标记的变量，将引发错误
- 变量可以被多次声明，能且只能被定义一次

#### 2.2.3 标识符

- C++标识符(identifier)由字母、数字和下划线组成，必须以字母或下划线开头，大小写敏感

##### 变量命名规范

- 标识符要能体现实际含义
- 变量名一般用小写字母
- 用户自定义的类名一般以大写字母开头
- 如果标识符由多个单词组成，则单词间应有明显区分(驼峰命名法：小驼峰法：变量;大驼峰法：类名，命名空间，属性等)

- C++关键字

| 第一列     | 第二列       | 第三列    | 第四列           | 第五列   |
| ---------- | ------------ | --------- | ---------------- | -------- |
| alingnas   | continue     | friend    | register         | true     |
| alignof    | decltype     | goto      | reinterpret_cast | try      |
| asm        | default      | if        | return           | typedef  |
| auto       | delete       | inline    | short            | typeid   |
| bool       | do           | int       | signed           | typename |
| break      | double       | long      | sizeof           | union    |
| case       | dynamic_cast | mutable   | static           | unsigned |
| catch      | else         | namespace | static_assert    | using    |
| char       | enum         | new       | static_cast      | virtual  |
| char16_t   | explicit     | noexcept  | struct           | void     |
| char32_t   | export       | nullptr   | switch           | volatile |
| calss      | extern       | operator  | template         | wchar_t  |
| const      | false        | private   | this             | while    |
| constexpr  | float        | protected | thread_local     |
| const_cast | for          | public    | throw            |

- C++操作符替代名

| 1   | 2      | 3     | 4      | 5     | 6      | 7      | 8     | 9   | 10  | 11  |
| --- | ------ | ----- | ------ | ----- | ------ | ------ | ----- | --- | --- | --- |
| and | bitand | compl | not_eq | or_eq | xor_eq | and_eq | bitor | not | or  | xor |

#### 2.2.4 名字的作用域

- 作用域scope
  - C++大多数作用域都以{}分隔
  - 同一名字在不同作用域中可能指向不同的实体
  - 名字的有效区域始于声明，结束于作用域末端
  - 全局作用域global scope main和大多数定义在函数体之外的名字具有全局作用域
  - 块作用域block scope，定义在块内的名字，在块外就无法访问

##### 嵌套的作用域

- 被包围的作用域称内层作用域inner scope，相对的为外层作用域outer scope
  - 内层作用域可以访问外层作用域
  - 内层作用域可以重新定义外层作用域的名字

### 2.3 复合类型

- 声明符语句：基本数据类型(base type) 声明符(declarator)
- 简单的声明符就是变量
- 复杂的声明符，基于简单的声明符得到更复杂的类型，并把它指定给变量

#### 2.3.1 引用

- 一般引用指左值引用(lvalue reference)，另一种右值引用(rvalue reference)主要用于内置类

##### 引用即别名

- 引用(reference)为对象起别名，引用类型必须引用(refers to)另外一种类型的对象(引用必须被初始化)
引用不是对象

##### 引用的定义

- 每个引用标识符必须紧以&符号开头,引用类型必须与绑定对象严格匹配(两种例外)，只能绑定在对象上，不能与字面值或表达式绑定。

```cpp
int i=1024,j=2048;
int &ri=i,&rj=j;
```

- 所以int &可以看成int型的引用类型，ri,rj看成引用变量
- 为了连续声明几个引用，int 和 &ri分开
- 引用不是对象，必须初始化，给引用变量赋值，就是给所引用的对象赋值，可以看成常量指针

#### 2.3.2 指针

- 指针(pointer)是“指向(point to)”另外一种类型的符合类型
- 指针本身是一个对象，可以赋值和拷贝，同一指针可以先后指向不同对象
- 块作用域中定义未初始化的指针，拥有一个不确定的值

```cpp
int *ip1,*ip2;//指向int类型对象的指针
```

- int *看作int型的指针类型，ip1,ip2看作指针对象

##### 获取对象的地址

- 所有指针的类型都要和它所指向的对象严格匹配(两种例外)

```cpp
//取地址符&
int ival = 42;
int *ip = &ival;
```

##### 指针值

- 指向一个对象
- 指向紧邻对象所占空间的下一个位置
- 空指针，指针没有指向任何对象
- 无效指针，上述之外的其他值
  - 拷贝或访问无效指针都将发生错误

##### 利用指针访问对象

```cpp
int i=42;
int &r=i;  //r引用
int *p;    //p指针
p=&i;      //取地址符
*p=i;      //*解引用符，*p 表示指针指向的对象
int &r2=*p;//引用与解引用符
```

- 声明语句中&和*用于组成符合类型，表达式中，转变为运算符

##### 空指针null pointer

```cpp
int *p1=nullptr;  //等同 int *p1=0;
int *p2=0;        //此处0为空指针字面值，类型与整型0不同
#include <cstdlib>//预处理变量NULL在头文件cstdlib中
int *p3=NULL;     //等同 int *p3=0;
```

##### 赋值和指针

- 赋值永远改变的是左值

##### 其他指针操作

- 指针有合法值，当着条件时，空指针为false，其他值为true
- 相同类型的合法指针，可以用==、!=进行比较，当指向的地址相同时为两个指针相等

##### void *指针

- 可以存放任意对象的地址
- 作用：和别的指针比较、作为函数的输入或输出、赋值给另外一个void*指针
- 不能直接操作void *指针所指对象

#### 2.3.3 理解符合类型的声明

##### 定义多个变量

```cpp
//注意区别
int *p1,p2;
int *p1,*p2
```

##### 指向指针的指针

```cpp
int ival=1024;
int *pi=&ival;
int **ppi=&pi;
```

##### 指向指针的引用

```cpp
int i=42;
int *p;
int *&r=p;//指针类型对象的引用
r=&i;//给引用变量赋值改变的是所引用的对象p的值
*r=0;//*r解引用得i,p指向的对象，i的值改为0
```

### 2.4 const 限定符

- const 限定的变量不能改变值，叫做常量，常量只能初始化不能单独赋值
- 被const限定的变量能参与运算，不能改变自身的值

#### 初始化和const

- 默认情况下，const对象仅在文件内有效

#### 需要在文件外生效，必须声明

```cpp
extern const int bufSize=fcn();//定义并初始化一个常量,可以被外部文件访问，只能出现一次
extern const int bufSize;//声明一个常量，可以被外部文件访问，可以出现多次
```

#### 2.4.1 const 的引用

- 对常量的引用(reference to const)
- 不能修改被绑定的值，不能给对常量的引用赋值
- 普通引用不能引用常量

##### 初始化和对const的引用

- 引用的类型必须与其所引用对象的类型一致，但有两种例外，其中之一
- 在初始化对const的引用时，允许用任意表达式、非常量对象、字面值作为初始值;
- 对变量的引用，可以通过引用改变引用对象的值，不允许表达式;

#### 2.4.2 指针和const

- 指向常量的指针(pointer to const)不能用于改变其所指对象的值
- 想存放常量对象的地址，只能使用指向常量的指针;
- 指针类型必须和所指对象的类型一致，有两个例外，其中之一：
  - 指向常量的指针指向一个非常量的对象，指向常量的指针不能改变指向变量对象的值，但可通过其他方法改变其值;

##### const指针

- 将指针本身定为常量，常量指针(const pointer)必须初始化

```cpp
    int a1 = 100, &b1 = a1, *c1 = &a1;
    const int a2 = 100, &b2 = a2, *c2 = &a2;
    const int a3 = 100, &b3 = a3, *const c3 = &a3;
    int a4 = 100, a5 = a4;
    const int &b4 = a4, *c4 = &a4, &d4 = b4, *e4 = c4, &b5 = a5, *const c5 = &a5;
    // int &d5 = b5, *e5 = c5;//底层const属性要一直
    const int a6 = 100;
    // int &b6 = a6, *c6 = &a6;
    //错误，a6是常量，b6，c6与却能改变先关联对象的值，矛盾
    /*
    总结：
    1.当涉及给引用或指针初始化时，看能否改变关联对象的值
    2.引用不是对象
    3.声明引用的const是底层const,声明指针的const有顶层const，也有底层const
    4.执行拷贝操作时，顶层const不受影响，底层const则必须类型一致
    */
```

- *引用与指针的区别*
  - *引用*
    - *引用是对象的别名，必须绑定一个对象且不能改变*
    - *引用必须初始化;*
    - *引用不是对象，没有对引用的引用，指向引用的指针，不存在引用本身是常量的说法，(所谓的“常量引用”是指对常量的引用，而不是引用本身是常量);*
    - *对非常量的引用，不能用常量，表达式，字面值初始化;*
    - *对常量的引用(常量引用)，可以用常量，表达式，字面值，非常量对象初始化.*

  - *指针*
    - *指针是地址，可以指向这个对象，也可以是指向另一个对象*
    - *指针不一定初始化，块作用域中未初始化的指针拥有一个未确定的值，但指向常量的指针必须初始化*
    - *指针是对象，有对指针的引用，指向指针的指针，常量指针*
    - *指针不能指向表达式，字面值，不能用表达式或字面值初始化*
    - *指向非常量的指针不能用常量对象初始化，常量对象只能拥有指向常量的指针*
    - *指向常量的指针可以指向常量，非常量对象*
    - *常量指针自身的值不能改变*
    - *常量指针可以改变其指向的非常量对象的值*
(mmd，绕来绕去的，脑壳痛)

#### 2.4.3 顶层const

- 顶层const(top-level-const)表示指针本身是个常量，底层const(low-level-const)表示指针指向的对象是常量，这是两个相互独立的问题
- 一般地，顶层const可以表示任意的对象是常量，底层const则与指针和引用等符合类型的基本类型部分有关，指针类型即可以是顶层const，也可以是底层const，指针左侧的const是底层const，指针右侧的const是顶层const，用于声明引用的const都是底层const
- 执行拷贝操作时，顶层const不受影响，底层const则必须类型一致，或能转换类型

```cpp
int i=0;
int *const p1=&i;      //不能改变p1的值，顶层const
const int ci=42;       //不能改变ci的值，顶层const
const int *p2=&ci;     //允许改变p2的值，底层const
const int *const p3=p2;//左侧const是底层const，右侧const是顶层const
const int &r=ci;       //用于声明引用的const都是底层const

i=ci;           //不受影响
p2=p3;          //指向的类型相同，p3的顶层const部分不受影响
//int *p=p3;    //错误，p3含底层const，p没有
p2=&i;          //int*能转换成const int*
//int &r=ci;    //错误，普通的int &不能绑定到int 常量上
const int &r2=i;//const int &可以绑定到一个普通int上
```

#### 2.4.4 constexpr 和常量表达式

- 常量表达式(const expression)是指不会改变并且在编译过程就能得到计算结果的表达式
- 用常量表达式初始化的const对象也是常量表达式

##### constexpr变量

- 允许将变量声明为constexpr类型，以便由编译器来验证变量的值是否是一个常量表达式
- 声明为constexpr的变量一定是一个常量，而且必须用常量表达式或constexpr函数初始化
- constexpr函数，足够简单，编译时就可以计算其结果

```cpp
constexpr int mf = 20;
constexpr int limit = mf + 1;
constexpr int sz = size();
```

##### 字面值类型

- 算术类型、引用、指针、constexpr类型都属于字面值类型，自定义类，IO库，string类型不是字面值类型

- 指针和引用都能定义成constexpr，constexpr指针必须初始值是nullptr或者0，或者是存储于某固定地址中的对象
- constexpr 引用能绑定固定地址的变量，constexpr指针能指向固定地址的变量

##### 指针和constexpr

- constexpr 声明中定义类一个指针，限定符constexpr仅对指针有效，与指针指向的对象无关

```cpp
const int *p=nullptr;//指向常量的指针 底层const
constexpr int *q=nullptr;//常量指针 顶层const

int j=0;
constexpr int i=42;//i的类型是整型常量
//i和j必须定义在函数体外(固定地址)
constexpr const int *p=&i;//常量指针p指向整型常量i
constexpr int *p1=&j;//p1是常量指针，指向整数j
    /*
    总结：
    1.constexpr只能是顶层const，constexpr只能常量表达式或constexpr函数初始化
    2.constexpr指针只能是空指针或固定位置对象，引用只能绑定固定位置对象
    */
```

- const 与constexpr区别
  - 都必须初始化
  - const可以是顶层const，也可以是底层const，
  - constexpr只能是顶层const，constexpr只能常量表达式或constexpr函数初始化
  - constexpr指针只能是空指针或固定位置对象，引用只能绑定固定位置对象

### 2.5 处理类型

#### 2.5.1 类型别名

- typedef 关键词

```cpp
typedef double wages;//wages 是double的同义词
typedef wages base, *p;//base 是double 的同义词，p是double *的同义词
```

- 别名声明(alias declaration)

```cpp
using SI=SalesItem;//SI是SalesItem的同义词
```

##### 指针、常量和类型别名

```cpp
typedef char *pstring;//pstring与char *同义,是指针类型
const pstring cstr=0; //cstr是const pstring类型的对象，即指向char类型对象的常量指针，同char *const cstr=0
const pstring *ps=&cstr;    //ps是指针，指向的对象是指针，指向的对象是指向char类型对象的常量指针
    /*
    总结，注意用别名与用类型名声明对象相同
    */
```

#### 2.5.2 auto类型说明符

- 把表达式赋值给变量，如果不知道表达式的类型，用auto类型说明符，auto定义的变量必须有初始值
- auto在一条语句中声明多个变量，变量的初始基本数据类型必须一样

```cpp
auto i=0,*p=&i;//i是整型，p是整型指针
//auto sz=0,pi=3.14;//错误，sz是整型，pi为浮点型
```

##### 复合类型、常量和auto

- 使用引用作为初始值时，编译器把引用的对象的类型作为auto的类型
- auto 一般会忽略掉顶层const，同时底层const会保留下来
- 希望推断出的auto类型是一个顶层const，需要明确指出
- 可以将引用的类型设为auto
- 设置一个类型为auto的引用时，初始值的顶层常量属性仍然保留，auto紧跟&和*时，理解为初始化
- 在同一条语句中定义多个变量，&和*只从属于某个声明符，而非基本数据类型的一部分

```cpp
int i=0,&r=i;//i是整型，r是i的别名
auto a=r;//将r赋值给a，r绑定的对象是整型，a是整型

const int ci=i,&cr=ci;//ci是整型常量，cr是对整形常量的引用
auto b=ci;//将ci赋值给b，b是整型(常量赋值给变量，ci的顶层const被忽略)
auto c=cr;//将cr引用的对象赋值给c，c是整型(cr是ci的别名)
auto d=&i;//d是一个整型指针
auto e=&ci;//e是一个指向整数常量的指针，对常量取地址是底层const

const auto f=ci;//希望推断出的auto类型是一个顶层const，需要明确指出

auto &g=ci;//g是一个绑定整形常量对象的引用，绑定到ci
//auto &h=42;//错误，不能为非常量引用绑定字面值，能自动识别字面值的类型，不能确定是常量，h为非常量对象引用
const auto &j=42;//可以为常量引用绑定字面值

auto k=ci，&l=i;//k是整数，l是对整型对象的引用
auto &m=ci,*p=&ci;//m是对整型常量对象的引用，p是一个指向整型常量的指针
//auto &n=i,*p2=&ci;//错误：i的类型是int，而p2是指向是const int对象的制作
```

#### 2.5.3 decltype 类型指示符

- 从表达式的类型推断出要定义的变量的类型，但不用该表达式的值初始化变量
- decltype返回该变量的类型(包括顶层const和引用在内)
- 引用都是作为所指对象的同义词出现，用在decltype处例外，表示引用

```cpp
decltype(f()) sum=x;//sum的类型就是函数f()d 返回类型
const int ci=0,&cj=ci;
decltype(ci) x=0;//x的类型是const int
decltype(cj) y=x;//y的类型是const int &,y绑定到变量x
//decltype(cj) z;//错误，z是一个引用，必须初始化
```

##### decltype 和引用

- 如果表达式向decltype返回一个引用类型，意味着表达式的结果对象能作为一条赋值语句的左值：

```cpp
int i=42,*p=&i,&r=i;
decltype(r+0) b;//加法的结果是int,b是一个未初始化的int，右值表达式类型为表达式计算结果的类型
//decltype(*p) c;//错误，解引用指针的类型是引用，而非该指针指向的对象的类型，c类型为int&,必须初始化
```

- decltype的结果类型与表达式形式密切相关。
- 变量名加一对括号，得到的类型与不加括号时会有不同
- 变量是可以作为赋值语句左值的特殊表达式,左值表达式类型为引用

```cpp
//decltype((i)) d;//错误：d是int&,必须初始化
decltype(i) e;//e是未初始化的int
```

### 2.6 自定义数据结构

- 数据结构就是把一组相关的数据元素组织起来然后使用它们的策略和方法。

#### 2.6.1 定义Sakes_data类型

```cpp
struct Sakes_data{
    std::string bookNo;
    unsigned units_sold=0;
    double revenue=0.0;
};
```

- 类体内部定义名字必须唯一，可以和类外部定义的名字重复。
- 类体结束的花括号后必须写一个分号，因为类体后面可以紧跟变量名以表示对该类型对象的定义。

```cpp
struct Sakes_data{
    std::string bookNo;
    unsigned units_sold=0;
    double revenue=0.0;
} accum,trans,*salesptr;
//等价于
struct Sakes_data{
    std::string bookNo;
    unsigned units_sold=0;
    double revenue=0.0;
};
Sakes_data accum,trans,*salesptr;
```

##### 类数据成员(data menber)

- 可以为数据成员提供一个类内初始值(in-class initializer)
- 创建对象时，类内初始值将用于初始化数据成员，没有初始值的成员将被默认初始化
- 类内初始值可以放在花括号里，或等号右边，不能用圆括号
- 使用圆括号会被认为是声明函数

```cpp
struct Sakes_data{
    std::string bookNo{};
    unsigned units_sold{0};
    double revenue{0.0;}
};
```

#### 2.6.2 使用Sakes_data类

##### 添加两个Sales_data对象

##### Sales_data对象读入数据

##### 输出两个Sales_data对象的和

```cpp
#include <iostream>
struct Sakes_data
{
    std::string bookNo{};
    unsigned units_sold{0};
    double revenue{0.0};
};
int main()
{
    Sakes_data data1, data2;
    double price = 0; //书的单价，用于计算销售收入
    //读入第1笔交易：ISBN、销售数量、单价
    std::cin >> data1.bookNo >> data1.units_sold >> price;
    //计算销售收入
    data1.revenue = data1.units_sold * price;
    //读入第2笔交易
    std::cin >> data2.bookNo >> data2.units_sold >> price;
    data2.revenue = data2.units_sold * price;

    if (data1.bookNo == data2.bookNo)
    {
        unsigned totalCnt = data1.units_sold + data2.units_sold;
        double totalRevenue = data1.revenue + data2.revenue;
        //输出：ISBN、总销售量、总销售额、平均价格
        std::cout << data1.bookNo << " " << totalCnt
                  << " " << totalRevenue << " ";

        if (totalCnt != 0)
            std::cout << totalRevenue / totalCnt << std::endl;
        else
            std::cout << "(no sales)" << std::endl;
        return 0; //表示成果
    }
    else
    { //两笔交易的ISBN不一样
        std::cerr << "Data must refer to the same ISBN"
                  << std::endl;
        return -1; //表示失败
    }
    return 0;
}
```

#### 2.6.3 编写自己的头文件

- 类可以定义在函数体外部
- 也可以在函数体内定义类，但不推荐
- 确保各个文件总类的定义一致，类通常被定义在头文件中

- 头文件通常包含哪些只能被定义一次的实体
- 头文件也经常用到其他头文件的功能

##### 预处理器概述

- 预处理器：确保头文件多次包含仍能安全工作的常用技术是预处理器(perprocessor)
- 预处理器是编译之前执行的一段程序
- \#include 是一项预处理功能
- 另一种预处理功能：头文件保护符(header guard)
- 预处理变量必须唯一，一般用全大写的头文件名

```cpp
#define 指令把一个名字设定为预处理变量
#ifdef 变量已定义时为真
#ifndef 变量未定义时为真
#endif 一旦检查结果为真，则执行后续操作直到#endif指令为止

#ifndef SALESITEM_H  //SALESITEM_H变量未定义，为真执行后续代码
#define SALESITEM_H  //SALESITEM_H变量已定义，再次包含此文件，不会继续执行后续代码
//……
#endif //执行到此结束
```

### 术语表

- `地址(address)`是一个数字，根据它可以找到内存中的一个字节。
- `别名声明(alias declaration)`为另外一种类型定义一个同义词：使用“名字=类型”的格式将名字作为该类型的同义词。
- `算术类型(arithmetic type`)布尔值、字符、整数、浮点数等内置类型。
- `数组(array)`是一种数据结构，存放着一组未命名的对象，可以通过索引来访问这些对象。3.5节将详细介绍数组的知识。
- `auto` 是一个类型说明符，通过变量的初始值来推断变量的类型。
- `基本类型(base type`)是类型说明符，可用const修饰，在声明语句中位于声明符之前。基本类型提供了最常见的数据类型，以此为基础构建声明符。
- `绑定(bind)`令某个名字与给定的实体关联在一起，使用该名字也就是使用该实体。例如，引用就是将某个名字与某个对象绑定在一起。
- `字节(byte)`内存中可寻址的最小单元，大多数机器的字节占8位。
- `类成员(class member)`类的组成部分。复合类型(compound type)是一种类型，它的定义以其他类型为基础。
- `const`是一种类型修饰符，用于说明永不改变的对象。const对象一旦定义就无法再赋新值，所以必须初始化。
- `常量指针(const pointer)`是一种指针，它的值永不改变。
- `常量引用(const reference)`是一种习惯叫法，含义是指向常量的引用。
- `常量表达式(const expression)`能在编译时计算并获取结果的表达式。
- `constexpr`是一种函数，用于代表一条常量表达式。6.5.2节(第214页)将介绍constexpr函数。
- `转换(conversion)`一种类型的值转变成另外一种类型值的过程。C++语言支持内置类型之间的转换。
- `数据成员(data member)`组成对象的数据元素，类的每个对象都有类的数据成员的一份拷贝。数据成员可以在类内部声明的同时初始化。
- `声明(declaration)`声称存在一个变量、函数或是别处定义的类型。名字必须在定义或声明之后才能使用。
- `声明符(declarator)`是声明的一部分，包括被定义的名字和类型修饰符，其中类型修饰符可以有也可以没有。
- `decltype`是一个类型说明符，从变量或表达式推断得到类型。
- `默认初始化(default initialization)`当对象未被显式地赋予初始值时执行的初始化行为。由类本身负责执行的类对象的初始化行为。全局作用域的内置类型对象初始化为0;局部作用域的对象未被初始化即拥有未定义的值。
- `定义(definition)`为某一特定类型的变量申请存储空间，可以选择初始化该变量。名字必须在定义或声明之后才能使用。
- `转义序列(escape sequence)`字符特别是那些不可打印字符的替代形式。转义以反斜线开头，后面紧跟一个字符，或者不多于3个八进制数字，或者字母x加上1个十六进制数。
- `全局作用域(global scope)`位于其他所有作用域之外的作用域。
- `头文件保护符(header guard)`使用预处理变量以防止头文件被某个文件重复包含。
- `标识符(identifier)`组成名字的字符序列，标识符对大小写敏感。
- `类内初始值(in-class initializer)`在声明类的数据成员时同时提供的初始值，必须置于等号右侧或花括号内。
- `在作用域内(in scope)`名字在当前作用域内可见。
- `被初始化(initialized`)变量在定义的同时被赋予初始值，变量一般都应该被初始化。
- `内层作用域(inner scope)`嵌套在其他作用域之内的作用域。
- `整型(integral type)`参见算术类型。
- `列表初始化(list initialization)`利用花括号把一个或多个初始值放在一起的初始化形式。
- `字面值(literal)`是一个不能改变的值，如数字、字符、字符串等。单引号内的是字符字面值，双引号内的是字符串字面值。
- `局部作用域(local scope)`是块作用域的习惯叫法。
- `底层const(low-level const)`一个不属于顶层的const，类型如果由底层常量定义，则不能被忽略。
- `成员(member)`类的组成部分。
- `不可打印字符(nonprintable character)`不具有可见形式的字符，如控制符、退格、换行符等。
- `空指针(null pointer)`值为0的指针，空指针合法但是不指向任何对象。
- `nullptr`是表示空指针的字面值常量。
- `对象(object)`是内存的一块区域，具有某种类型，变量是命名了的对象。
- `外层作用域(outer scope)`嵌套着别的作用域的作用域。
- `指针(pointer)`是一个对象，存放着某个对象的地址，或者某个对象存储区域之后的下一地址，或者0。
- `指向常量的指针(pointer to const)`是一个指针，存放着某个常量对象的地址。指向常量的指针不能用来改变它所指对象的值。
- `预处理器(preprocessor)`在C++编译过程中执行的一段程序。
- `预处理变量(preprocessor variable)`由预处理器管理的变量。在程序编译之前，预处理器负责将程序中的预处理变量替换成它的真实值。
- `引用(reference)`是某个对象的别名。
- `对常量的引用(reference to const)`是一个引用，不能用来改变它所绑定对象的值。对常量的引用可以绑定常量对象，或者非常量对象，或者表达式的结果。
- `作用域(scope)`是程序的一部分，在其中某些名字有意义。C++有几级作用域：
- `全局(global)`——名字定义在所有其他作用域之外。
- `类(class)`——名字定义在类内部。
- `命名空间(namespace)`——名字定义在命名空间内部。
- `块(block)`——名字定义在块内部。名字从声明位置开始直至声明语句所在的作用域末端为止都是可用的。
- `分离式编译(separate compilation)`把程序分割为多个单独文件的能力。
- `带符号类型(signed)`保存正数、负数或0的整型。
- `字符串(string`)是一种库类型，表示可变长字符序列。
- `struct`是一个关键字，用于定义类。
- `临时值(temporary`)编译器在计算表达式结果时创建的无名对象。为某表达式创建了一个临时值，则此临时值将一直存在直到包含有该表达式的最大的表达式计算完成为止。
- `顶层const(top-level const)`是一个const，规定某对象的值不能改变。
- `类型别名(type alias)`是个名字，是另外一个类型的同义词，通过关键宁typedef或别名声明语句来定义。
- `类型检查(type checking)`是一个过程，编译器检查程序使用某给定类型对象的方式与该类型的定义是否一致。
- `类型说明符(type specifier)`类型的名字。
- `typedef`为某类型定义一个别名。当关键字typedef作为声明的基本类型出现时，声明中定义的名字就是类型名。
- `未定义(undefined)`即C++语言没有明确规定的情况。不论是否有意为之，未定义行为都可能引发难以追踪的运行时错误、安全问题和可移植性问题。
- `未初始化(uninitialized)`变量已定义但未被赋予初始值。一般来说，试图访问未初始化变量的值将引发未定义行为无符号类型(unsigned)保存大于等于0的整型。
- `变量(variable)`命名的对象或引用。C++语言要求变量要先声明后使用。
- `void*`可以指向任意非常量的指针类型，不能执行解引用操作。
- `void类型`是一种有特殊用处的类型，既无操作也无值。不能定义一个void类型的变量。
- `字(word)`在指定机器上进行整数运算的自然单位。一般来说，字的空间足够存放地址。32位机器上的字通常占据4个字节。
- `&运算符(&operator)`取地址运算符。
- `*运算符(*operator)`解引用运算符。解引用一个指针将返回该指针所指的对象，为解引用的结果赋值也就是为指针所指的对象赋值。
- `#define`是一条预处理指令，用于定义一个预处理变量。
- `#endif`是一条预处理指令，用于结束一个#ifdef或#ifndef区域。
- `#ifdef`是一条预处理指令，用于判断给定的变量是否已经定义。
- `#ifndef`是一条预处理指令，用于判断给定的变量是否尚未定义。
