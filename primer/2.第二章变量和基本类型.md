# primer学习

## 第二章 变量和基本类型

### 2.1 基本内置类型

- 算术类型（arithmetic tyoe）
  - 整型（integral type）
    - 字符
    - 整型数
    - 布尔值
  - 浮点型
- 空类型（void）

#### 2.1.1 算术类型

- C++算术类型

| 类型        | 含义           | 最小尺寸     |
| ----------- | -------------- | ------------ |
| bool        | 布尔类型       | 未定义       |
| char        | 字符           | 8位          |
| wchar_t     | 宽字符         | 16位         |
| char16_t    | Unicode字符    | 16位         |
| char32_t    | Unicode字符    | 32位         |
| short       | 短整型         | 16位         |
| int         | 整型           | 16位         |
| long        | 长整型         | 32位         |
| long long   | 长整型         | 64位         |
| float       | 单精度浮点数   | 6位有效数字  |
| double      | 双精度浮点数   | 10位有效数字 |
| long double | 扩展精度浮点数 | 10位有效数字 |

##### 带符号类型和不带符号类型

| 默认类型 | signed      | unsigned           |
| -------- | ----------- | ------------------ |
| char     | signed char | unsigned char      |
| short    | short       | unsigned short     |
| int      | int         | unsigned int       |
| long     | long        | unsigned long      |
| long     | long        | unsigned long long |

#### 2.1.2 类型转换

- 含有无符号类型的表达式
（略）

#### 2.1.3 字面值常量

##### 整型和浮点型字面值

| 字面值名称 | 字面值例子        |
| ---------- | ----------------- |
| 二进制     | 0b11              |
| 十进制     | 20                |
| 八进制     | 024               |
| 十六进制   | 0x14              |
| 浮点数     | 3.14159 3.14159e0 |

##### 字符和字符串字面值

| 字面值名称 | 字面值例子    |
| ---------- | ------------- |
| 字符       | 'a'           |
| 字符串     | "Hello world" |

##### 转义序列

| 字符常量形式 | 含义       | 十六进制 | 十六进制表示       | 八进制表示       |
| ------------ | ---------- | -------- | ------------------ | ---------------- |
| \a           | 响铃       | 07       | char(0x07) '\x07'  | char(007) '\007' |
| \n           | 换行       | 0A       | char(0x0A) '\x0A'  | char(012) '\012' |
| \t           | 水平制表符 | 09       | char(0x09)  '\x09' | char(011) '\011' |
| \v           | 垂直制表符 | 0B       | char(0x0B)  '\x0B' | char(013) '\013' |
| \b           | 退格       | 08       | char(0x08)  '\x08' | char(010) '\010' |
| \r           | 回车       | 0D       | char(0x0D)  '\x0D' | char(015) '\015' |
| \f           | 换页       | 0C       | char(0x0C)  '\x0C' | char(014) '\014' |
| \\\          | 字符'\\'   | 5C       | char(0x5C)  '\x5C' | char(134) '\134' |
| \"           | 双引号     | 22       | char(0x22)  '\x22' | char(042) '\042' |
| \'           | 单引号     | 27       | char(0x27)  '\x27' | char(047) '\047' |

##### 指定字面值的类型

| 前缀 | 含义          | 类型     |
| ---- | ------------- | -------- |
| u    | Unicode16字符 | char16_t |
| U    | Unicode32字符 | char32_t |
| L    | 宽字符        | wchar_t  |
| u8   | UTF-8         | char     |

| 整型字面值后缀 | 整型字面值最小匹配类型 | 浮点字面值后缀 | 浮点字面值最小匹配类型 |
| -------------- | ---------------------- | -------------- | ---------------------- |
| u or U         | unsigned               | f or F         | float                  |
| l or L         | long                   | l or L         | Long double            |
| ll or LL       | long long              |                |                        |

##### 布尔和指针字面值

| 字面值名称 | 字面值例子 |
| ---------- | ---------- |
| bool       | true false |
| 指针       | nullptr    |

### 2.2 变量

#### 2.2.1 变量定义

##### 初始值

- 初始化：创建变量并赋初值
- 赋值：擦出当前值，以新值替代

##### 列表初始化

- 一组用花括号括起来的初始值

##### 默认初始化

- 定义于任何函数体外地变量被初始化为0
- 定义在函数体内部的内置类型变量将不被初始化

#### 2.2.2 声明变量和定义的关系

- 声明非定义

```cpp
extern int i;//extern 只声明不赋值
```

- 声明并定义

```cpp
int j;//声明并定义j
```

- 定义非声明

```cpp
extern double pi=3.1416；//显式初始化的声明不在是声明，是定义
```

- 函数体内部初始化extern标记的变量，将引发错误
- 变量可以被多次声明，能且只能被定义一次

#### 2.2.3 标识符

- C++标识符（identifier）由字母、数字和下划线组成，必须以字母或下划线开头，大小写敏感

##### 变量命名规范

- 标识符要能体现实际含义
- 变量名一般用小写字母
- 用户自定义的类名一般以大写字母开头
- 如果标识符由多个单词组成，则单词间应有明显区分（驼峰命名法：小驼峰法：变量；大驼峰法：类名，命名空间，属性等）

- C++关键字

| 第一列     | 第二列       | 第三列    | 第四列           | 第五列   |
| ---------- | ------------ | --------- | ---------------- | -------- |
| alingnas   | continue     | friend    | register         | true     |
| alignof    | decltype     | goto      | reinterpret_cast | try      |
| asm        | default      | if        | return           | typedef  |
| auto       | delete       | inline    | short            | typeid   |
| bool       | do           | int       | signed           | typename |
| break      | double       | long      | sizeof           | union    |
| case       | dynamic_cast | mutable   | static           | unsigned |
| catch      | else         | namespace | static_assert    | using    |
| char       | enum         | new       | static_cast      | virtual  |
| char16_t   | explicit     | noexcept  | struct           | void     |
| char32_t   | export       | nullptr   | switch           | volatile |
| calss      | extern       | operator  | template         | wchar_t  |
| const      | false        | private   | this             | while    |
| constexpr  | float        | protected | thread_local     |
| const_cast | for          | public    | throw            |

- C++操作符替代名

| 1   | 2      | 3     | 4      | 5     | 6      | 7      | 8     | 9   | 10  | 11  |
| --- | ------ | ----- | ------ | ----- | ------ | ------ | ----- | --- | --- | --- |
| and | bitand | compl | not_eq | or_eq | xor_eq | and_eq | bitor | not | or  | xor |

#### 2.2.4 名字的作用域

- 作用域scope
  - C++大多数作用域都以{}分隔
  - 同一名字在不同作用域中可能指向不同的实体
  - 名字的有效区域始于声明，结束于作用域末端
  - 全局作用域global scope main和大多数定义在函数体之外的名字具有全局作用域
  - 块作用域block scope，定义在块内的名字，在块外就无法访问

##### 嵌套的作用域

- 被包围的作用域称内层作用域inner scope，相对的为外层作用域outer scope
  - 内层作用域可以访问外层作用域
  - 内层作用域可以重新定义外层作用域的名字

### 2.3 复合类型

- 声明符语句：基本数据类型（base type） 声明符（declarator）
- 简单的声明符就是变量
- 复杂的声明符，基于简单的声明符得到更复杂的类型，并把它指定给变量

#### 2.3.1 引用

- 一般引用指左值引用（lvalue reference），另一种右值引用（rvalue reference）主要用于内置类

##### 引用即别名

- 引用（reference）为对象起别名，引用类型必须引用（refers to）另外一种类型的对象（引用必须被初始化）
引用不是对象

##### 引用的定义

- 每个引用标识符必须紧以&符号开头,引用类型必须与绑定对象严格匹配（两种例外），只能绑定在对象上，不能与字面值或表达式绑定。

```cpp
int i=1024,j=2048;
int &ri=i,&rj=j;
```

- 所以int &可以看成int型的引用类型，ri,rj看成引用变量
- 为了连续声明几个引用，int 和 &ri分开
- 引用不是对象，必须初始化，给引用变量赋值，就是给所引用的对象赋值，可以看成常量指针

#### 2.3.2 指针

- 指针（pointer）是“指向（point to）”另外一种类型的符合类型
- 指针本身是一个对象，可以赋值和拷贝，同一指针可以先后指向不同对象
- 块作用域中定义未初始化的指针，拥有一个不确定的值

```cpp
int *ip1,*ip2;//指向int类型对象的指针
```

- int *看作int型的指针类型，ip1,ip2看作指针对象

##### 获取对象的地址

- 所有指针的类型都要和它所指向的对象严格匹配（两种例外）

```cpp
//取地址符&
int ival = 42;
int *ip = &ival;
```

##### 指针值

- 指向一个对象
- 指向紧邻对象所占空间的下一个位置
- 空指针，指针没有指向任何对象
- 无效指针，上述之外的其他值
  - 拷贝或访问无效指针都将发生错误

##### 利用指针访问对象

```cpp
int i=42;
int &r=i;  //r引用
int *p;    //p指针
p=&i;      //取地址符
*p=i;      //*解引用符，*p 表示指针指向的对象
int &r2=*p;//引用与解引用符
```

- 声明语句中&和*用于组成符合类型，表达式中，转变为运算符

##### 空指针null pointer

```cpp
int *p1=nullptr;  //等同 int *p1=0;
int *p2=0;        //此处0为空指针字面值，类型与整型0不同
#include <cstdlib>//预处理变量NULL在头文件cstdlib中
int *p3=NULL;     //等同 int *p3=0;
```

##### 赋值和指针

- 赋值永远改变的是左值

##### 其他指针操作

- 指针有合法值，当着条件时，空指针为false，其他值为true
- 相同类型的合法指针，可以用==、!=进行比较，当指向的地址相同时为两个指针相等

##### void *指针

- 可以存放任意对象的地址
- 作用：和别的指针比较、作为函数的输入或输出、赋值给另外一个void*指针
- 不能直接操作void *指针所指对象

#### 2.3.3 理解符合类型的声明

##### 定义多个变量

```cpp
//注意区别
int *p1,p2;
int *p1,*p2
```

##### 指向指针的指针

```cpp
int ival=1024;
int *pi=&ival;
int **ppi=&pi;
```

##### 指向指针的引用

```cpp
int i=42;
int *p;
int *&r=p;//指针类型对象的引用
r=&i;//给引用变量赋值改变的是所引用的对象p的值
*r=0;//*r解引用得i,p指向的对象，i的值改为0
```

### 2.4 const 限定符

- const 限定的变量不能改变值，叫做常量，常量只能初始化不能单独赋值
- 被const限定的变量能参与运算，不能改变自身的值

#### 初始化和const

- 默认情况下，const对象仅在文件内有效

#### 需要在文件外生效，必须声明

```cpp
extern const int bufSize=fcn();//定义并初始化一个常量,可以被外部文件访问，只能出现一次
extern const int bufSize;//声明一个常量，可以被外部文件访问，可以出现多次
```

#### 2.4.1 const 的引用

- 对常量的引用（reference to const）
- 不能修改被绑定的值，不能给对常量的引用赋值
- 普通引用不能引用常量

##### 初始化和对const的引用

- 引用的类型必须与其所引用对象的类型一致，但有两种例外，其中之一
- 在初始化对const的引用时，允许用任意表达式、非常量对象、字面值作为初始值；
- 对变量的引用，可以通过引用改变引用对象的值，不允许表达式；

#### 2.4.2 指针和const

- 指向常量的指针（pointer to const）不能用于改变其所指对象的值
- 想存放常量对象的地址，只能使用指向常量的指针；
- 指针类型必须和所指对象的类型一致，有两个例外，其中之一：
  - 指向常量的指针指向一个非常量的对象，指向常量的指针不能改变指向变量对象的值，但可通过其他方法改变其值；

##### const指针

- 将指针本身定为常量，常量指针（const pointer）必须初始化

```cpp
    int a1 = 100, &b1 = a1, *c1 = &a1;
    const int a2 = 100, &b2 = a2, *c2 = &a2;
    const int a3 = 100, &b3 = a3, *const c3 = &a3;
    int a4 = 100, a5 = a4;
    const int &b4 = a4, *c4 = &a4, &d4 = b4, *e4 = c4, &b5 = a5, *const c5 = &a5;
    // int &d5 = b5, *e5 = c5;//底层const属性要一直
    const int a6 = 100;
    // int &b6 = a6, *c6 = &a6;
    //错误，a6是常量，b6，c6与却能改变先关联对象的值，矛盾
    /*
    总结：
    1.当涉及给引用或指针初始化时，看能否改变关联对象的值
    2.引用不是对象
    3.声明引用的const是底层const,声明指针的const有顶层const，也有底层const
    4.执行拷贝操作时，顶层const不受影响，底层const则必须类型一致
    */
```

- *引用与指针的区别*
  - *引用*
    - *引用是对象的别名，必须绑定一个对象且不能改变*
    - *引用必须初始化；*
    - *引用不是对象，没有对引用的引用，指向引用的指针，不存在引用本身是常量的说法，(所谓的“常量引用”是指对常量的引用，而不是引用本身是常量）；*
    - *对非常量的引用，不能用常量，表达式，字面值初始化；*
    - *对常量的引用（常量引用），可以用常量，表达式，字面值，非常量对象初始化.*

  - *指针*
    - *指针是地址，可以指向这个对象，也可以是指向另一个对象*
    - *指针不一定初始化，块作用域中未初始化的指针拥有一个未确定的值，但指向常量的指针必须初始化*
    - *指针是对象，有对指针的引用，指向指针的指针，常量指针*
    - *指针不能指向表达式，字面值，不能用表达式或字面值初始化*
    - *指向非常量的指针不能用常量对象初始化，常量对象只能拥有指向常量的指针*
    - *指向常量的指针可以指向常量，非常量对象*
    - *常量指针自身的值不能改变*
    - *常量指针可以改变其指向的非常量对象的值*
（mmd，绕来绕去的，脑壳痛）

#### 2.4.3 顶层const

- 顶层const（top-level-const）表示指针本身是个常量，底层const（low-level-const）表示指针指向的对象是常量，这是两个相互独立的问题
- 一般地，顶层const可以表示任意的对象是常量，底层const则与指针和引用等符合类型的基本类型部分有关，指针类型即可以是顶层const，也可以是底层const，指针左侧的const是底层const，指针右侧的const是顶层const，用于声明引用的const都是底层const
- 执行拷贝操作时，顶层const不受影响，底层const则必须类型一致，或能转换类型

```cpp
int i=0;
int *const p1=&i;      //不能改变p1的值，顶层const
const int ci=42;       //不能改变ci的值，顶层const
const int *p2=&ci;     //允许改变p2的值，底层const
const int *const p3=p2;//左侧const是底层const，右侧const是顶层const
const int &r=ci;       //用于声明引用的const都是底层const

i=ci;           //不受影响
p2=p3;          //指向的类型相同，p3的顶层const部分不受影响
//int *p=p3;    //错误，p3含底层const，p没有
p2=&i;          //int*能转换成const int*
//int &r=ci;    //错误，普通的int &不能绑定到int 常量上
const int &r2=i;//const int &可以绑定到一个普通int上
```

#### 2.4.4 constexpr 和常量表达式

- 常量表达式（const expression）是指不会改变并且在编译过程就能得到计算结果的表达式
- 用常量表达式初始化的const对象也是常量表达式

##### constexpr变量

- 允许将变量声明为constexpr类型，以便由编译器来验证变量的值是否是一个常量表达式
- 声明为constexpr的变量一定是一个常量，而且必须用常量表达式或constexpr函数初始化
- constexpr函数，足够简单，编译时就可以计算其结果

```cpp
constexpr int mf = 20;
constexpr int limit = mf + 1;
constexpr int sz = size();
```

##### 字面值类型

- 算术类型、引用、指针、constexpr类型都属于字面值类型，自定义类，IO库，string类型不是字面值类型

- 指针和引用都能定义成constexpr，constexpr指针必须初始值是nullptr或者0，或者是存储于某固定地址中的对象
- constexpr 引用能绑定固定地址的变量，constexpr指针能指向固定地址的变量

##### 指针和constexpr

- constexpr 声明中定义类一个指针，限定符constexpr仅对指针有效，与指针指向的对象无关

```cpp
const int *p=nullptr;//指向常量的指针 底层const
constexpr int *q=nullptr;//常量指针 顶层const

int j=0;
constexpr int i=42;//i的类型是整型常量
//i和j必须定义在函数体外（固定地址）
constexpr const int *p=&i;//常量指针p指向整型常量i
constexpr int *p1=&j;//p1是常量指针，指向整数j
    /*
    总结：
    1.constexpr只能是顶层const，constexpr只能常量表达式或constexpr函数初始化
    2.constexpr指针只能是空指针或固定位置对象，引用只能绑定固定位置对象
    */
```

- const 与constexpr区别
  - 都必须初始化
  - const可以是顶层const，也可以是底层const，
  - constexpr只能是顶层const，constexpr只能常量表达式或constexpr函数初始化
  - constexpr指针只能是空指针或固定位置对象，引用只能绑定固定位置对象

### 2.5 处理类型

#### 2.5.1 类型别名

- typedef 关键词

```cpp
typedef double wages;//wages 是double的同义词
typedef wages base, *p;//base 是double 的同义词，p是double *的同义词
```

- 别名声明（alias declaration）

```cpp
using SI=SalesItem;//SI是SalesItem的同义词
```

##### 指针、常量和类型别名

```cpp
typedef char *pstring;//pstring与char *同义,是指针类型
const pstring cstr=0; //cstr是const pstring类型的对象，即指向char类型对象的常量指针，同char *const cstr=0
const pstring *ps=&cstr;    //ps是指针，指向的对象是指针，指向的对象是指向char类型对象的常量指针
    /*
    总结，注意用别名与用类型名声明对象相同
    */
```

#### 2.5.2 auto类型说明符

- 把表达式赋值给变量，如果不知道表达式的类型，用auto类型说明符，auto定义的变量必须有初始值
- auto在一条语句中声明多个变量，变量的初始基本数据类型必须一样

```cpp
auto i=0,*p=&i;//i是整型，p是整型指针
//auto sz=0,pi=3.14;//错误，sz是整型，pi为浮点型
```

##### 复合类型、常量和auto

- 使用引用作为初始值时，编译器把引用的对象的类型作为auto的类型
- auto 一般会忽略掉顶层const，同时底层const会保留下来
- 希望推断出的auto类型是一个顶层const，需要明确指出
- 可以将引用的类型设为auto
- 设置一个类型为auto的引用时，初始值的顶层常量属性仍然保留，auto紧跟&和*时，理解为初始化
- 在同一条语句中定义多个变量，&和*只从属于某个声明符，而非基本数据类型的一部分

```cpp
int i=0,&r=i;//i是整型，r是i的别名
auto a=r;//将r赋值给a，r绑定的对象是整型，a是整型

const int ci=i,&cr=ci;//ci是整型常量，cr是对整形常量的引用
auto b=ci;//将ci赋值给b，b是整型（常量赋值给变量，ci的顶层const被忽略）
auto c=cr；//将cr引用的对象赋值给c，c是整型（cr是ci的别名）
auto d=&i;//d是一个整型指针
auto e=&ci;//e是一个指向整数常量的指针，对常量取地址是底层const

const auto f=ci;//希望推断出的auto类型是一个顶层const，需要明确指出

auto &g=ci;//g是一个绑定整形常量对象的引用，绑定到ci
//auto &h=42;//错误，不能为非常量引用绑定字面值，能自动识别字面值的类型，不能确定是常量，h为非常量对象引用
const auto &j=42;//可以为常量引用绑定字面值

auto k=ci，&l=i;//k是整数，l是对整型对象的引用
auto &m=ci,*p=&ci;//m是对整型常量对象的引用，p是一个指向整型常量的指针
//auto &n=i,*p2=&ci;//错误：i的类型是int，而p2是指向是const int对象的制作
```

#### 2.5.3 decltype 类型指示符

- 从表达式的类型推断出要定义的变量的类型，但不用该表达式的值初始化变量
- decltype返回该变量的类型（包括顶层const和引用在内）
- 引用都是作为所指对象的同义词出现，用在decltype处例外，表示引用

```cpp
decltype(f()) sum=x;//sum的类型就是函数f()d 返回类型
const int ci=0,&cj=ci;
decltype(ci) x=0;//x的类型是const int
decltype(cj) y=x;//y的类型是const int &,y绑定到变量x
//decltype(cj) z;//错误，z是一个引用，必须初始化
```

##### decltype 和引用

- 如果表达式向decltype返回一个引用类型，意味着表达式的结果对象能作为一条赋值语句的左值：

```cpp
int i=42,*p=&i,&r=i;
decltype(r+0) b;//加法的结果是int,b是一个未初始化的int，右值表达式类型为表达式计算结果的类型
//decltype(*p) c;//错误，解引用指针的类型是引用，而非该指针指向的对象的类型，c类型为int&,必须初始化
```

- decltype的结果类型与表达式形式密切相关。
- 变量名加一对括号，得到的类型与不加括号时会有不同
- 变量是可以作为赋值语句左值的特殊表达式,左值表达式类型为引用

```cpp
//decltype((i)) d;//错误：d是int&,必须初始化
decltype(i) e;//e是未初始化的int
```

### 2.6 自定义数据结构

- 数据结构就是把一组相关的数据元素组织起来然后使用它们的策略和方法。

#### 2.6.1 定义Sakes_data类型

```cpp
struct Sakes_data{
    std::string bookNo;
    unsigned units_sold=0;
    double revenue=0.0;
};
```

- 类体内部定义名字必须唯一，可以和类外部定义的名字重复。
- 类体结束的花括号后必须写一个分号，因为类体后面可以紧跟变量名以表示对该类型对象的定义。

```cpp
struct Sakes_data{
    std::string bookNo;
    unsigned units_sold=0;
    double revenue=0.0;
} accum,trans,*salesptr;
//等价于
struct Sakes_data{
    std::string bookNo;
    unsigned units_sold=0;
    double revenue=0.0;
};
Sakes_data accum,trans,*salesptr;
```

##### 类数据成员（data menber）

- 可以为数据成员提供一个类内初始值（in-class initializer）
- 创建对象时，类内初始值将用于初始化数据成员，没有初始值的成员将被默认初始化
- 类内初始值可以放在花括号里，或等号右边，不能用圆括号
- 使用圆括号会被认为是声明函数

```cpp
struct Sakes_data{
    std::string bookNo{};
    unsigned units_sold{0};
    double revenue{0.0;}
};
```

#### 2.6.2 使用Sakes_data类

##### 添加两个Sales_data对象

##### Sales_data对象读入数据

##### 输出两个Sales_data对象的和

```cpp
#include <iostream>
struct Sakes_data
{
    std::string bookNo{};
    unsigned units_sold{0};
    double revenue{0.0};
};
int main()
{
    Sakes_data data1, data2;
    double price = 0; //书的单价，用于计算销售收入
    //读入第1笔交易：ISBN、销售数量、单价
    std::cin >> data1.bookNo >> data1.units_sold >> price;
    //计算销售收入
    data1.revenue = data1.units_sold * price;
    //读入第2笔交易
    std::cin >> data2.bookNo >> data2.units_sold >> price;
    data2.revenue = data2.units_sold * price;

    if (data1.bookNo == data2.bookNo)
    {
        unsigned totalCnt = data1.units_sold + data2.units_sold;
        double totalRevenue = data1.revenue + data2.revenue;
        //输出：ISBN、总销售量、总销售额、平均价格
        std::cout << data1.bookNo << " " << totalCnt
                  << " " << totalRevenue << " ";

        if (totalCnt != 0)
            std::cout << totalRevenue / totalCnt << std::endl;
        else
            std::cout << "(no sales)" << std::endl;
        return 0; //表示成果
    }
    else
    { //两笔交易的ISBN不一样
        std::cerr << "Data must refer to the same ISBN"
                  << std::endl;
        return -1; //表示失败
    }
    return 0;
}
```

#### 2.6.3 编写自己的头文件

- 类可以定义在函数体外部
- 也可以在函数体内定义类，但不推荐
- 确保各个文件总类的定义一致，类通常被定义在头文件中

- 头文件通常包含哪些只能被定义一次的实体
- 头文件也经常用到其他头文件的功能

##### 预处理器概述

- 预处理器：确保头文件多次包含仍能安全工作的常用技术是预处理器（perprocessor）
- 预处理器是编译之前执行的一段程序
- \#include 是一项预处理功能
- 另一种预处理功能：头文件保护符（header guard）
- 预处理变量必须唯一，一般用全大写的头文件名

```cpp
#define 指令把一个名字设定为预处理变量
#ifdef 变量已定义时为真
#ifndef 变量未定义时为真
#endif 一旦检查结果为真，则执行后续操作直到#endif指令为止

#ifndef SALESITEM_H  //SALESITEM_H变量未定义，为真执行后续代码
#define SALESITEM_H  //SALESITEM_H变量已定义，再次包含此文件，不会继续执行后续代码
//……
#endif //执行到此结束
```

### 术语表

- `地址（address）`是一个数字，根据它可以找到内存中的一个字节。
- `别名声明（alias declaration）`为另外一种类型定义一个同义词：使用“名字=类型”的格式将名字作为该类型的同义词。
- `算术类型（arithmetic type`）布尔值、字符、整数、浮点数等内置类型。
- `数组（array）`是一种数据结构，存放着一组未命名的对象，可以通过索引来访问这些对象。3.5节将详细介绍数组的知识。
- `auto` 是一个类型说明符，通过变量的初始值来推断变量的类型。
- `基本类型（base type`）是类型说明符，可用const修饰，在声明语句中位于声明符之前。基本类型提供了最常见的数据类型，以此为基础构建声明符。
- `绑定（bind）`令某个名字与给定的实体关联在一起，使用该名字也就是使用该实体。例如，引用就是将某个名字与某个对象绑定在一起。
- `字节（byte）`内存中可寻址的最小单元，大多数机器的字节占8位。
- `类成员（class member）`类的组成部分。复合类型（compound type）是一种类型，它的定义以其他类型为基础。
- `const`是一种类型修饰符，用于说明永不改变的对象。const对象一旦定义就无法再赋新值，所以必须初始化。
- `常量指针（const pointer）`是一种指针，它的值永不改变。
- `常量引用（const reference）`是一种习惯叫法，含义是指向常量的引用。
- `常量表达式（const expression）`能在编译时计算并获取结果的表达式。
- `constexpr`是一种函数，用于代表一条常量表达式。6.5.2节（第214页）将介绍constexpr函数。
- `转换（conversion）`一种类型的值转变成另外一种类型值的过程。C++语言支持内置类型之间的转换。
- `数据成员（data member）`组成对象的数据元素，类的每个对象都有类的数据成员的一份拷贝。数据成员可以在类内部声明的同时初始化。
- `声明（declaration）`声称存在一个变量、函数或是别处定义的类型。名字必须在定义或声明之后才能使用。
- `声明符（declarator）`是声明的一部分，包括被定义的名字和类型修饰符，其中类型修饰符可以有也可以没有。
- `decltype`是一个类型说明符，从变量或表达式推断得到类型。
- `默认初始化（default initialization）`当对象未被显式地赋予初始值时执行的初始化行为。由类本身负责执行的类对象的初始化行为。全局作用域的内置类型对象初始化为0；局部作用域的对象未被初始化即拥有未定义的值。
- `定义（definition）`为某一特定类型的变量申请存储空间，可以选择初始化该变量。名字必须在定义或声明之后才能使用。
- `转义序列（escape sequence）`字符特别是那些不可打印字符的替代形式。转义以反斜线开头，后面紧跟一个字符，或者不多于3个八进制数字，或者字母x加上1个十六进制数。
- `全局作用域（global scope）`位于其他所有作用域之外的作用域。
- `头文件保护符（header guard）`使用预处理变量以防止头文件被某个文件重复包含。
- `标识符（identifier）`组成名字的字符序列，标识符对大小写敏感。
- `类内初始值（in-class initializer）`在声明类的数据成员时同时提供的初始值，必须置于等号右侧或花括号内。
- `在作用域内（in scope）`名字在当前作用域内可见。
- `被初始化（initialized`）变量在定义的同时被赋予初始值，变量一般都应该被初始化。
- `内层作用域（inner scope）`嵌套在其他作用域之内的作用域。
- `整型（integral type）`参见算术类型。
- `列表初始化（list initialization）`利用花括号把一个或多个初始值放在一起的初始化形式。
- `字面值（literal）`是一个不能改变的值，如数字、字符、字符串等。单引号内的是字符字面值，双引号内的是字符串字面值。
- `局部作用域（local scope）`是块作用域的习惯叫法。
- `底层const（low-level const）`一个不属于顶层的const，类型如果由底层常量定义，则不能被忽略。
- `成员（member）`类的组成部分。
- `不可打印字符（nonprintable character）`不具有可见形式的字符，如控制符、退格、换行符等。
- `空指针（null pointer）`值为0的指针，空指针合法但是不指向任何对象。
- `nullptr`是表示空指针的字面值常量。
- `对象（object）`是内存的一块区域，具有某种类型，变量是命名了的对象。
- `外层作用域（outer scope）`嵌套着别的作用域的作用域。
- `指针（pointer）`是一个对象，存放着某个对象的地址，或者某个对象存储区域之后的下一地址，或者0。
- `指向常量的指针（pointer to const）`是一个指针，存放着某个常量对象的地址。指向常量的指针不能用来改变它所指对象的值。
- `预处理器（preprocessor）`在C++编译过程中执行的一段程序。
- `预处理变量（preprocessor variable）`由预处理器管理的变量。在程序编译之前，预处理器负责将程序中的预处理变量替换成它的真实值。
- `引用（reference）`是某个对象的别名。
- `对常量的引用（reference to const）`是一个引用，不能用来改变它所绑定对象的值。对常量的引用可以绑定常量对象，或者非常量对象，或者表达式的结果。
- `作用域（scope）`是程序的一部分，在其中某些名字有意义。C++有几级作用域：
- `全局（global）`——名字定义在所有其他作用域之外。
- `类（class）`——名字定义在类内部。
- `命名空间（namespace）`——名字定义在命名空间内部。
- `块（block）`——名字定义在块内部。名字从声明位置开始直至声明语句所在的作用域末端为止都是可用的。
- `分离式编译（separate compilation）`把程序分割为多个单独文件的能力。
- `带符号类型（signed）`保存正数、负数或0的整型。
- `字符串（string`）是一种库类型，表示可变长字符序列。
- `struct`是一个关键字，用于定义类。
- `临时值（temporary`）编译器在计算表达式结果时创建的无名对象。为某表达式创建了一个临时值，则此临时值将一直存在直到包含有该表达式的最大的表达式计算完成为止。
- `顶层const（top-level const）`是一个const，规定某对象的值不能改变。
- `类型别名（type alias）`是个名字，是另外一个类型的同义词，通过关键宁typedef或别名声明语句来定义。
- `类型检查（type checking）`是一个过程，编译器检查程序使用某给定类型对象的方式与该类型的定义是否一致。
- `类型说明符（type specifier）`类型的名字。
- `typedef`为某类型定义一个别名。当关键字typedef作为声明的基本类型出现时，声明中定义的名字就是类型名。
- `未定义（undefined）`即C++语言没有明确规定的情况。不论是否有意为之，未定义行为都可能引发难以追踪的运行时错误、安全问题和可移植性问题。
- `未初始化（uninitialized）`变量已定义但未被赋予初始值。一般来说，试图访问未初始化变量的值将引发未定义行为无符号类型（unsigned）保存大于等于0的整型。
- `变量（variable）`命名的对象或引用。C++语言要求变量要先声明后使用。
- `void*`可以指向任意非常量的指针类型，不能执行解引用操作。
- `void类型`是一种有特殊用处的类型，既无操作也无值。不能定义一个void类型的变量。
- `字（word）`在指定机器上进行整数运算的自然单位。一般来说，字的空间足够存放地址。32位机器上的字通常占据4个字节。
- `&运算符（&operator）`取地址运算符。
- `*运算符（*operator）`解引用运算符。解引用一个指针将返回该指针所指的对象，为解引用的结果赋值也就是为指针所指的对象赋值。
- `#define`是一条预处理指令，用于定义一个预处理变量。
- `#endif`是一条预处理指令，用于结束一个#ifdef或#ifndef区域。
- `#ifdef`是一条预处理指令，用于判断给定的变量是否已经定义。
- `#ifndef`是一条预处理指令，用于判断给定的变量是否尚未定义。
