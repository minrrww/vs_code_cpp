# primer C++ 第五版

## 第一章 开始

本章介绍C++的大部分基础内容:类型、变量、表达式、语句及函数。在这个过程中,我们会简要介绍如何编译及运行程序。

在学习完本章并认真完成练习之后,你将具备编写、编译及运行简单程序的能力。后续章节将假定你已掌握本章中介绍的语言特性,并将更详细地解释这些特性。

学习一门新的程序设计语言的最好方法就是练习编写程序。在本章中,我们将编写个程序来解决简单的书店问题。

我们的书店保存所有销售记录的档案,每条记录保存了某本书的一次销售的信息(一册或多册)。每条记录包含三个数据项:

```text
0-201-70353-x 4 24.99
```

第一项是书的ISBN号(国际标准书号,一本书的唯一标识),第二项是售出的册数,最后一项是书的单价。有时,书店老板需要查询此档案,计算每本书的销售量、销售额及平均售价。

为了编写这个程序,我们需要使用若干C++的基本特性。而且,我们需要了解如何编译及运行程序。

虽然我们还没有编写这个程序,但显然它必须

- 定义变量
- 进行输入和输出
- 使用数据结构保存数据
- 检测两条记录是否有相同的ISBN
- 包含一个循环来处理销售档案中的每条记录

我们首先介绍如何用C++来解决这些子问题,然后编写书店程序。

### 1.1 编写一个简单的C++程序

每个C++程序都包含一个或多个函数(function),其中一个必须命名为main。操作系统通过调用main来运行C++程序。下面是一个非常简单的main函数,它什么也不干,只是返回给操作系统一个值:

```cpp
int main()
{
    return 0;
}
```

一个函数的定义包含四部分:返回类型(return type)、函数名(function name)、个括号包围的形参列表(parameter list,允许为空)以及函数体(function body)。虽然main函数在某种程度上比较特殊,但其定义与其他函数是一样的。

在本例中,main的形参列表是空的(()中什么也没有)。6.2.5节(第196页)将会讨论main的其他形参类型。

main函数的返回类型必须为int,即整数类型。int类型是一种内置类型(built-in type),即语言自身定义的类型。

函数定义的最后一部分是函数体,它是一个以左花括号(curly brace)开始,以右花括号结束的语句块(block of statements):

```cpp
{
return O;
}
```

这个语句块中唯一的一条语句是return,它结束函数的执行。在本例中,return还会向调用者返回一个值。当return语句包括一个值时,此返回值的类型必须与函数的返回类型相容。在本例中,main的返回类型是int,而返回值0的确是一个int类型的值。

> **Note**
> 请注意,return语句末尾的分号。在C++中,大多数C++语句以分号表示结束。它们很容易被忽略,但如果忘记了写分号,就会导致莫名其妙的编译错误。

在大多数系统中,main的返回值被用来指示状态。返回值0表明成功,非0的返回值的含义由系统定义,通常用来指出错误类型。

> **重要概念:类型**
> 类型是程序设计最基本的概念之一,在本书中我们会反复遇到它。一种类型不仅定义了数据元素的内容,还定义了这类数据上可以进行的运算。
> 程序所处理的数据都保存在变量中,而每个变量都有自己的类型。如果一个名为v的变量的类型为T,我们通常说“v具有类型T”,或等价的,“v是一个T类型变量”。

#### 1.1.1 编译、运行程序

编写好程序后,我们就需要编译它。如何编译程序依赖于你使用的操作系统和编译器。你所使用的特定编译器的相关使用细节,请查阅参考手册或询问经验丰富的同事。

很多PC机上的编译器都具备集成开发环境(Integrated Developed Environment,IDE),将编译器与其他程序创建和分析工具包装在一起。在开发大型程序时,这类集成环境可能是非常有用的工具,但需要一些时间来学习如何高效地使用它们。学习如何使用这类开发环境已经超出了本书的范围。

大部分编译器,包括集成IDE的编译器,都会提供一个命令行界面。除非你已经了解IDE,否则你会觉得借助命令行界面开始学习Ct+还是很容易的。这种学习方式的好处是,可以先将精力集中于C++语言本身(而不是一些开发工具),而且,一旦你掌握了语言,IDE通常是很容易学习的。

##### 程序源文件命名约定

无论你使用命令行界面或者IDE,大多数编译器都要求程序源码存储在一个或多个文件中。程序文件通常被称为源文件(source file)。在大多数系统中,源文件的名字以一个后缀为结尾,后缀是由一个句点后接一个或多个字符组成的。后缀告诉系统这个文件是一个CH程序。不同编译器使用不同的后缀命名约定,最常见的包括`.cc`、`.cxx`、`.cpp`、`.cp`及`.C`。

##### 从命令行运行编译器

如果我们正在使用命令行界面,那么通常是在一个控制台窗口内(例如UNIX系统中的外壳程序窗口或者Windows系统中的命令提示符窗口)编译程序。假定我们的main程,序保存在文件progl.cc中,可以用如下命令来编译它

`$ CC progl.cc`

其中,CC是编译器程序的名字,$是系统提示符。编译器生成一个可执行文件。Windows系统会将这个可执行文件命名为progl.exe。UNIX系统中的编译器通常将可执行文件命名为a.out。

为了在Windows系统中运行一个可执行文件,我们需要提供可执行文件的文件名,可以忽略其扩展名,exe:

`$ progl`

在一些系统中,即使文件就在当前目录或文件夹中,你也必须显式指出文件的位置。在此情况下,我们可以键入

`$.Iprogl`

“.”后跟一个反斜线指出该文件在当前目录中。

为了在UNIX系统中运行一个可执行文件,我们需要使用全文件名,包括文件扩展名:

`$ a.out`

如果需要指定文件位置,需要用一个“.”后跟一个斜线来指出可执行文件位于当前目录中。

`$./a.out`

访问main的返回值的方法依赖于系统。在UNIX和Windows系统中,执行完一个程序后,都可以通过echo命令获得其返回值。

在UNIX系统中,通过如下命令获得状态:

`$ echo $？`

在Windows系统中查看状态可键入:

`$ echo ERRORLEVEL`

> **运行GNU或微软编译器**
> 在不同操作和编译器系统中,运行C++编译器的命令也各不相同。最常用的编译器,是GNU编译器和微软Visual Studio编译器。默认情况下,运行GNU编译器的命令是g++:
>
> `$ g++-o progl progl.cc`
>
>此处,$是系统提示符。-o prog1是编译器参数,指定了可执行文件的文件名。在不同的操作系统中,此命令生成一个名为progl或progl.exe的可执行文件。在UNIX系统中,可执行文件没有后级;在windows系统中,后缀为.exe。如果省略了-oprogl参数,在UNIX系统中编译器会生成一个名为a.out的可执行文件,在Windows系统中则会生成一个名为a.exe的可执行文件(注意:根据使用的GNU编译器的版本,你可能需要指定-std=C++0x参数来打开对C++11的支持)。
>运行微软Visual Studio 2010编译器的命令为cl:
>
>`C:\Users ImeI Programs> cl/EHsc progl.cpp`
>
>此处,C:\Users Ime\Programs>是系统提示符,Userslme\Programs是当前目录名(即当前文件夹)。命令cl调用编译器,/EHSc是编译器选项,用来打开标准异,常处理。微软编译器会自动生成一个可执行文件,其名字与第一个源文件名对应。可执行文件的文件名与源文件名相同,后缀为.exe。在此例中,可执行文件的文件名为progl.exe。
>编译器通常都包含一些选项,能对有问题的程序结构发出警告。打开这些选项通常是一个好习惯。我们习惯在GNU编译器中使用-Wal1选项,在微软编译器中则使用/W4。
>更详细的信息请查阅你使用的编译器的参考手册。

### 1.2 初识输入输出

C++语言并未定义任何输入输出(IO)语句,取而代之,包含了一个全面的标准库(standard library)来提供IO机制(以及很多其他设施)。对于很多用途,包括本书中的示例来说,我们只需了解IO库中一部分基本概念和操作。

本书中的很多示例都使用了 iostream库。iostream库包含两个基础类型istream和ostream,分别表示输入流和输出流。一个流就是一个字符序列,是从IO设备读出或写入IO设备的。术语“流”(stream)想要表达的是,随着时间的推移,字符是顺序生成或消耗的。

#### 标准输入输出对象

标准库定义了4个10对象。为了处理输入,我们使用一个名为cin(发音为see-in)的istream类型的对象。这个对象也被称为标准输入(standard input)。对于输出,我们使用一个名为cout(发音为see-out)的ostream类型的对象。此对象也被称为标准输出(standard output)。标准库还定义了其他两个ostream对象,名为cerr和clog(发音分别为see-err和see-log)。我们通常用cerr来输出警告和错误消息,因此它也被称为标准错误(standard error)。而clog用来输出程序运行时的一般性信息。

系统通常将程序所运行的窗口与这些对象关联起来。因此,当我们读取cin,数据将从程序正在运行的窗口读入,当我们向cout,cerr和clog写入数据时,将会写到同个窗口

#### 一个使用IO库的程序

在书店程序中,我们需要将多条记录合并成单一的汇总记录。作为一个相关的,但更简单的问题,我们先来看一下如何将两个数相加。通过使用10库,我们可以扩展main程序,使之能提示用户输入两个数,然后输出它们的和:

```cpp
#include <iostream>
int main()
{
    std::cout <<"Enter two numbers:"<< std::endl;
    int vl = 0,v2 = 0;
    std::cin >> vl >> v2
    std::cout <<"The sum of"<< vl <<"and"<< v2
              <<"is"<< vl + v2 << std::endl;
    return 0;
}
```

这个程序开始时在用户屏幕打印

`Enter two numbers:`

然后等待用户输入。如果用户键入

`3 7`

然后键入一个回车,则程序产生如下输出:

`The sum of 3 and 7 is 10`

程序的第一行

```cpp
#include <iostream>
```

告诉编译器我们想要使用iostream库。尖括号中的名字(本例中是iostream)指出了一个头文件(header)。每个使用标准库设施的程序都必须包含相关的头文件。#include指令和头文件的名字必须写在同一行中。通常情况下,#include指令必须出现在所有函数之外。我们一般将一个程序的所有#include指令都放在源文件的开始位置。

#### 向流写入数据

main的函数体的第一条语句执行了一个表达式(expression)。在CH中,一个表达式产生一个计算结果,它由一个或多个运算对象和(通常是)一个运算符组成。这条语句中的表达式使用了输出运算符(<<)在标准输出上打印消息:

```cpp
std::cout <<"Enter two numbers:"<< std::endl;
```

<<运算符接受两个运算对象:左侧的运算对象必须是一个ostream对象,右侧的运算对象是要打印的值。此运算符将给定的值写到给定的ostream对象中。输出运算符的计算结果就是其左侧运算对象。即,计算结果就是我们写入给定值的那个ostream对象。

我们的输出语句使用了两次<<运算符。因为此运算符返回其左侧的运算对象,因此第一个运算符的结果成为了第二个运算符的左侧运算对象。这样,我们就可以将输出请求连接起来。因此,我们的表达式等价于

```cpp
(std::cout <<"Enter two numbers:")<< std::endl;
```

链中每个运算符的左侧运算对象都是相同的,在本例中是std::cout。我们也可以用两条语句生成相同的输出:

```cpp
std::cout <<"Enter two numbers:"
std::cout << std::endl;
```

第一个输出运算符给用户打印一条消息。这个消息是一个字符串字面值常量(string literal),是用一对双引号包围的字符序列。在双引号之间的文本被打印到标准输出。

第二个运算符打印endl,这是一个被称为操纵符(manipulator)的特殊值。写入 endl的效果是结束当前行,并将与设备关联的缓冲区(buffer)中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中,而不是仅停留在内存中等待写入流。

>**WARNING**
>程序员常常在调试时添加打印语句。这类语句应该保证“一直”刷新流。否则,如果程序崩溃,输出可能还留在缓冲区中,从而导致关于程序崩溃位置的错误推断。

#### 使用标准库中的名字

细心的读者可能会注意到这个程序使用了std::cout和std::endl,而不是直接的cout 和endl。前级std::指出名字cout和endl是定义在名为std的命名空间(namespace)中的。命名空间可以帮助我们避免不经意的名字定义冲突,以及使用库中相同名字导致的冲突。标准库定义的所有名字都在命名空间std中。

通过命名空间使用标准库有一个副作用:当使用标准库中的一个名字时,必须显式说明我们想使用来自命名空间std中的名字。例如,需要写出std::cout,通过使用作用域运算符(::)来指出我们想使用定义在命名空间std中的名字cout。3.1节(第74页)
将给出一个更简单的访问标准库中名字的方法。

#### 从流读取数据

在提示用户输入数据之后,接下来我们希望读入用户的输入。首先定义两个名为v1和v2的变量(variable)来保存输入:

```cpp
int vl = 0,v2 = 0;
```

我们将这两个变量定义为int类型,int是一种内置类型,用来表示整数。还将它们初始化(initialize)为0。初始化一个变量,就是在变量创建的同时为它赋予一个值。

下一条语句是

```cpp
std::cin >> vl >> v2;
```

它读入输入数据。输入运算符(>>)与输出运算符类似,它接受一个istream作为其左侧运算对象,接受一个对象作为其右侧运算对象。它从给定的istream读入数据,并存入给定对象中。与输出运算符类似,输入运算符返回其左侧运算对象作为其计算结果。因此,此表达式等价于

```cpp
(std::cin) >> vl>> v2;
```

由于此运算符返回其左侧运算对象,因此我们可以将一系列输入请求合并到单一语句中。本例中的输入操作从std::cin读入两个值,并将第一个值存入v1,将第二个值存入v2。换句话说,它与下面两条语句的执行结果是一样的

```cpp
std::cin >> vl;
std::cin >> v2;
```

#### 完成程序

剩下的就是打印计算结果了:

```cpp
std::cout <<"The sum of"<< vl <<"and"<< v2
           <<"is"<< vl + v2 << std::endl;
```

这条语句虽然比提示用户输入的打印语句更长,但原理上是一样的,它将每个运算对象打印在标准输出上。本例一个有意思的地方在于,运算对象并不都是相同类型的值。某些运算对象是字符串字面值常量,例如"The sum of"。其他运算对象则是int值,如vl、v2以及算术表达式vl+v2的计算结果。标准库定义了不同版本的输入输出运算符,来处理这些不同类型的运算对象。

### 1.3 注释

在程序变得更复杂之前,我们应该了解一下C++是如何处理注释(comments)的。注释可以帮助人类读者理解程序。注释通常用于概述算法,确定变量的用途,或者解释晦涩难懂的代码段。编译器会忽略注释,因此注释对程序的行为或性能不会有任何影响。虽然编译器会忽略注释,但读者并不会。即使系统文档的其他部分已经过时,程序员也倾向于相信注释的内容是正确可信的。因此,错误的注释比完全没有注释更糟糕,因为它会误导读者。因此,当你修改代码时,不要忘记同时更新注释！

#### C++注释种类

C++中有两种注释:单行注释和界定符对注释。单行注释以双斜线(//)开始,以换行符结束。当前行双斜线右侧的所有内容都会被编译器忽略,这种注释可以包含任何文本,包括额外的双斜线。

另一种注释使用继承自C语言的两个界定符(/\*和\*/)。这种注释以/\*开始,以\*/结束,可以包含除\*/外的任意内容,包括换行符。编译器将落在/\*和\*/之间的所有内容都当作注释。

注释界定符可以放置于任何允许放置制表符、空格符或换行符的地方。注释界定符可以跨越程序中的多行,但这并不是必须的。当注释界定符跨越多行时,最好能显式指出其内部的程序行都属于多行注释的一部分。我们所采用的风格是,注释内的每行都以一个星号开头,从而指出整个范围都是多行注释的一部分。

程序中通常同时包含两种形式的注释。注释界定符对通常用于多行解释,而双斜线注释常用于半行和单行附注。

```cpp
#include <iostream>
/*
 *简单主函数:
 *读取两个数,求它们的和
 */
int main()
{
//提示用户输入两个数
std::cout <<"Enter two numbers:"<< std::endl;
int vl =0,v2=0;//保存我们读入的输入数据的变量
std::cin >> vl >> v2;//读取输入数据
std::cout <<"The sum of"<< vl <<"and"<< v2
<<"is"<< vl + v2 << std::endl;
return 0;
}
```

>**Note**
>在本书中,我们用楷体来突出显示注释。在实际程序中,注释文本的显示形式是否区别于程序代码文本的显示,依赖于你所使用的程序设计环境是否提供这,一特性。

#### 注释界定符不能嵌套

界定符对形式的注释是以/\*开始,以\*/结束的。因此,一个注释不能嵌套在另一个注释之内。编译器对这类问题所给出的错误信息可能是难以理解、令人迷惑的。例如,在你的系统中编译下面的程序,就会产生错误:

```cpp
/*
 *注释对/*  */不能嵌套。
 *“不能嵌套”几个字会被认为是源码,
 *像剩余程序一样处理
 */
int main()
{
return 0;
}
```

我们通常需要在调试期间注释掉一些代码。由于这些代码可能包含界定符对形式的注释,因此可能导致注释嵌套错误,因此最好的方式是用单行注释方式注释掉代码段的每一行。

```cpp
// /*
// *单行注释中的任何内容都会被忽略
// *包括嵌套的注释对也一样会被忽略
// */
```

### 1.4 控制流

语句一般是顺序执行的:语句块的第一条语句首先执行,然后是第二条语句,依此类推。当然,少数程序,包括我们解决书店问题的程序,都可以写成只有顺序执行的形式。

但程序设计语言提供了多种不同的控制流语句,允许我们写出更为复杂的执行路径。

#### 1.4.1 while语句

while 语句反复执行一段代码,直至给定条件为假为止。我们可以用while语句编写一段程序,求1到10这10个数之和:

```cpp
#include <iostream>
int main()
{
    int sum = 0,val = 1;
    //只要val的值小于等于10,while循环就会持续执行
    while(val <= 10){
        sum += val;//将sum + val赋予sum.
        ++val;//将val加1
    }
    std::cout <<"Sum of 1 to 10 inclusive is"
              << sum << std::endl;return 0;
}
```

我们编译并执行这个程序,它会打印出

`Sum of 1 to 10 inclusive is 55`

与之前的例子一样,我们首先包含头文件iostream,然后定义main。在main中我们定义两个int变量:sum用来保存和;val用来表示从1到10的每个数。我们将sum的初值设置为O,val从1开始。

这个程序的新内容是while语句。while语句的形式为

```text
while(condition)
    statement
```

while语句的执行过程是交替地检测condition条件和执行关联的语句statement,直至condition为假时停止。所谓条件(condition)就是一个产生真或假的结果的表达式。只要condition为真,statement就会被执行。当执行完statement,会再次检测condition。如果condition仍为真,statement再次被执行。while语句持续地交替检测condition和执行statement,直至condition为假为止。

在本程序中,while语句是这样的

```cpp
//只要val的值小于等于10,while循环就会持续执行
while(val <= 10){
    sum += val;//将sum + val赋予sum
    ++val;//将val加1
}
```

条件中使用了小于等于运算符(<=)来比较val的当前值和10。只要val小于等于10,条件即为真。如果条件为真,就执行while循环体。在本例中,循环体是由两条语句组成的语句块:

```cpp
{
    sum += val;//将sum + val赋予sum
    ++val;//将val加1
}
```

所谓语句块(block),就是用花括号包围的零条或多条语句的序列。语句块也是语句的一种,在任何要求使用语句的地方都可以使用语句块。在本例中,语句块的第一条语句使用了复合赋值运算符(+=)。此运算符将其右侧的运算对象加到左侧运算对象上,将结果保存到左侧运算对象中。它本质上与一个加法结合一个赋值(assignment)是相同的:

```cpp
sum = sum + val;//将sum + val赋予sum
```

因此,语句块中第一条语句将val的值加到当前和sum上,并将结果保存在sum中。

下一条语句

```cpp
++val;//将val加1
```

使用前缀递增运算符(++)。递增运算符将运算对象的值增加1。++val等价于val=val+1。

执行完while循环体后,循环会再次对条件进行求值。如果val的值(现在已经增加了)仍然小于等于10,则while的循环体会再次执行。循环连续检测条件、执行循环体,直至val不再小于等于10为止。

一旦val大于10,程序跳出while循环,继续执行while之后的语句。在本例中,继续执行打印输出语句,然后执行return语句完成main程序。

#### 1.4.2 for 语句

在我们的while循环例子中,使用了变量val来控制循环执行次数。我们在循环条件中检测val的值,在while循环体中将val递增。

这种在循环条件中检测变量、在循环体中递增变量的模式使用非常频繁,以至于C++语言专门定义了第二种循环语句——for语句,来简化符合这种模式的语句。可以用for语句来重写从1加到10的程序:

```cpp
#include <iostream>
int main()
{
    int sum =0;
    //从1加到10
    for(int val = 1;val <= 10;++val)
        sum += val;//等价于sum= sum + val
    std::cout <<"Sum of 1 to 10 inclusive is"
              << sum << std::endl;
    return 0;
}
```

与之前一样,我们定义了变量sum,并将其初始化为0。在此版本中,val的定义是for语句的一部分:

```cpp
for (int val = 1;val <= 10;++val)
    sum += val;
```

每个for语句都包含两部分:循环头和循环体。循环头控制循环体的执行次数,它由三部分组成:一个初始化语句(init-statement)、一个循环条件(condition)以及一个表达式(expression)。在本例中,初始化语句为

```cpp
int val = 1
```

它定义了一个名为val的int型对象,并为其赋初值1。变量val仅在for循环内部存在,在循环结束之后是不能使用的。初始化语句只在for循环入口处执行一次。循环条件

```cpp
val <= 10
```

比较val的值和10,循环体每次执行前都会先检查循环条件。只要val小于等于10,就会执行for循环体。表达式在for循环体之后执行。在本例中,表达式

```cpp
++val
```

使用前缀递增运算符将val的值增加1。执行完表达式后,for语句重新检测循环条件。如果val的新值仍然小于等于10,就再次执行for循环体。执行完循环体后,再次将val的值增加1。循环持续这一过程直至循环条件为假。

在此循环中,for循环体执行加法

```cpp
sum += val;//等价sum = sum + val
```

简要重述一下for循环的总体执行流程:

1. 创建变量val,将其初始化为1。
2. 检测val是否小于等于10。若检测成功,执行for循环体。若失败,退出循环,继续执行for循环体之后的第一条语句。
3. 将val的值增加1。
4. 重复第2步中的条件检测,只要条件为真就继续执行剩余步骤。

#### 1.4.3 读取数量不定的输入数据

在前一节中,我们编写程序实现了1到10这10个整数求和。扩展此程序一个很自然的方向是实现对用户输入的一组数求和。在这种情况下,我们预先不知道要对多少个数求和,这就需要不断读取数据直至没有新的输入为止:

```cpp
#include <iostream>
int main()
{
    int sum= D,value = 0;
    //读取数据直到遇到文件尾,计算所有读入的值的和
    while(std::cin >> value)
        sum += value;//等价sum = sum + value
    std::cout <<"Sum is:"<< sum << std::endl;
    return 0;
}
```

如果我们输入

`3 4 5 6`

则程序会输出

`Sum is:18`

main的首行定义了两个名为sum和value的int变量,均初始化为0。我们使用value保存用户输入的每个数,数据读取操作是在while的循环条件中完成的:

```cpp
while(std::cin >> value)
```

while循环条件的求值就是执行表达式

```cpp
std::cin >> value
```

此表达式从标准输入读取下一个数,保存在value中。输入运算符(参见1.2节,第7页)返回其左侧运算对象,在本例中是std::cin。因此,此循环条件实际上检测的是std::cin。

当我们使用一个istream对象作为条件时,其效果是检测流的状态。如果流是有效的,即流未遇到错误,那么检测成功。当遇到文件结束符(end-of-file),或遇到一个无效输入时(例如读入的值不是一个整数),istream对象的状态会变为无效。处于无效状态,的istream对象会使条件变为假。

因此,我们的while循环会一直执行直至遇到文件结束符(或输入错误)。while循环体使用复合赋值运算符将当前值加到sum上。一旦条件失败,while循环将会结束。我们将执行下一条语句,打印sum的值和一个endl。

>**从键盘输入文件结束符**
>当从键盘向程序输入数据时,对于如何指出文件结束,不同操作系统有不同的约定。在Windows系统中,输入文件结束符的方法是敲Ctrl+Z(按住Ctrl键的同时按Z键),然后按Enter或Return键。在UNIX系统中,包括Mac OS X系统中,文件结束符输入是用Ctrl+D。

---

>**再探编译**
>编译器的一部分工作是寻找程序文本中的错误。编译器没有能力检查一个程序是否按照其作者的意图工作,但可以检查形式(form)上的错误。下面列出了一些最常见的编译器可以检查出的错误。
>**语法错误**(syntax error):程序员犯了C++语言文法上的错误。下面程序展示了一些常见的语法错误;每条注释描述了下一行中语句存在的错误:

```cpp
//错误:main的参数列表漏掉了
int main({
    //错误:endl后使用了冒号而非分号
    std::cout <<"Read each file."<< std::endl:
    //错误:字符串字面常量的两侧漏掉了引号
    std::cout << Update master.<< std::endl;
    //错误:漏掉了第二个输出运算符
    std::cout <<"Write new master."std::endl;
    //错误:return语句漏掉了分号
    return 0
```

>**类型错误**(type error):C++中每个数据项都有其类型。例如,10的类型是int(或者更通俗地说,“10是一个int型数据”)。单词"hello",包括两侧的双引号标记,则是一个字符串字面值常量。一个类型错误的例子是,向一个期望参数为int的函数传递了一个字符串字面值常量。
>**声明错误**(declaration error):C1+程序中的每个名字都要先声明后使用。名字声明失败通常会导致一条错误信息。两种常见的声明错误是:对来自标准库的名字忘记使用,std::、标识符名字拼写错误:

```cpp
#include <iostream>
int main()
{
    int vl = 0,v2 = 0;
    std::cin >> v>> v2;//错误:使用了"v"而非"vl"
    //错误:cout未定义;应该是std::cout
    cout << vl + v2 << std::endl;
    return O;
}
```

>错误信息通常包含一个行号和一条简短描述,描述了编译器认为的我们所犯的错误。按照报告的顺序来逐个修正错误,是一种好习惯。因为一个单个错误常常会具有传递效应,导致编译器在其后报告比实际数量多得多的错误信息。另一个好习惯是在每修正一个错误后就立即重新编译代码,或者最多是修正了一小部分明显的错误后就重新编译。这就是所谓的“编辑-编译-调试”(edit-compile-debug)周期。

#### 1.4.4 if 语句

与大多数语言一样,C++也提供了if语句来支持条件执行。我们可以用if语句写一个程序,来统计在输入中每个值连续出现了多少次:

```cpp
int currVal = 0, val = 0; // currVal是我们正在统计的数;我们将读入的新值存入val
//读取第一个数,并确保实有数据可以处理
if (cin >> currVal)
{
    int cnt = 1; //保存我们正在处理的当前值的个数
    while (cin >> val)
    {                       //读取剩余的数
        if (val == currVal) //如果值相同
            ++cnt;          // cnt自加1
        else
        { //否则,打印前一个值得个数
            cout << currVal << " occurs "
                 << cnt << " times" << endl;
            currVal = val; //记住新值
            cnt = 1;       //重置计数器
        }
    } // while循环在这里结束
    //记住打印文件中最后一个值得个数
    cout << currVal << " occurs "
         << cnt << " times" << endl;
} //最外层的if语句在这里结束
```

如果我们输入如下内容:

`42 42 42 42 42 55 55 62 100 100 100`

则输出应该是:

```text
42 occurs 5 times
55 occurs 2 times
62 occurs 1 times
100 occurs 3 times
```

有了之前多个程序的基础,你对这个程序中的大部分代码应该比较熟悉了。程序以两个变量val和currVal的定义开始:currVal记录我们正在统计出现次数的那个数;val则保存从输入读取的每个数。与之前的程序相比,新的内容就是两个if语句。第一条if语句

```cpp
if(std::cin >> currVal){
    //...
}//最外层的if语句在这里结束
```

保证输入不为空。与while语句类似,if也对一个条件进行求值。第一条if语句的条件是读取一个数值存入currVal中。如果读取成功,则条件为真,我们继续执行条件之后的语句块。该语句块以左花括号开始,以return语句之前的右花括号结束。

如果需要统计出现次数的值,我们就定义cnt,用来统计每个数值连续出现的次数。与上一小节的程序类似,我们用一个while循环反复从标准输入读取整数。

while的循环体是一个语句块,它包含了第二条if语句:

```cpp
if(val == currVal)//如果值相同
    ++cnt;//将cnt加1
else{//否则,打印前一个值的个数
    std::cout << currVal <<"occurs"
              << cnt <<"times"<< std::endl;
    currVal = val;//记住新值
    cnt = 1;//重置计数器
}
```

这条if语句中的条件使用了相等运算符(==)来检测val是否等于currVal。如果是,我们执行紧跟在条件之后的语句。这条语句将cnt增加1,表明我们再次看到了currVal。

如果条件为假,即val不等于currVal,则执行else之后的语句。这条语句是个由一条输出语句和两条赋值语句组成的语句块。输出语句打印我们刚刚统计完的值的出现次数。赋值语句将cnt重置为1,将currVal重置为刚刚读入的值val。

>**WARNING**
>C++用=进行赋值,用=作为相等运算符。两个运算符都可以出现在条件中。一个常见的错误是想在条件中使用=(相等判断),却误用了=。

---

>**关键概念:C++程序的缩进和格式**
>C++程序很大程度上是格式自由的,也就是说,我们在哪里放置花括号、缩进、注释以及换行符通常不会影响程序的语义。例如,花括号表示main函数体的开始,它可以放在main的同一行中;也可以像我们所做的那样,放在下一行的起始位置;还可以放在我们喜欢的其他任何位置。唯一的要求是左花括号必须是main的形参列表后第一个非空、非注释的字符。
>虽然很大程度上可以按照自己的意愿自由地设定程序的格式,但我们所做的选择会影响程序的可读性。例如,我们可以将整个main函数写在很长的单行内,虽然这样是合乎语法的,但会非常难读。
>关于C/C++的正确格式的辩论是无休止的。我们的信条是,不存在唯一正确的风格,但保持一致性是非常重要的。例如,大多数程序员都对程序的组成部分设置恰当的缩进,就像我们在之前的例子中对main函数中的语句和循环体所做的那样。对于作为函数界定符的花括号,我们习惯将其放在单独一行中。我们还习惯对复合IO表达式设置缩进,以使输入输出运算符排列整齐。其他一些缩进约定也都会令越来越复杂的程序更加清晰易读。
>我们要牢记一件重要的事情:其他可能的程序格式总是存在的。当你要选择一种格式风格时,思考一下它会对程序的可读性和易理解性有什么影响,而一旦选择了一种风格,就要坚持使用

### 1.5 类简介

在解决书店程序之前,我们还需要了解的唯一一个C++特性,就是如何定义一个数据结构(data structure)来表示销售数据。在C++中,我们通过定义一个类(class)来定义自己的数据结构。一个类定义了一个类型,以及与其关联的一组操作。类机制是C++最重要的特性之一。实际上,C++最初的一个设计焦点就是能定义使用上像内置类型一样自然的类类型(class type)。

在本节中,我们将介绍一个在编写书店程序中会用到的简单的类。当我们在后续章节中学习了更多关于类型、表达式、语句和函数的知识后,会真正实现这个类。

为了使用类,我们需要了解三件事情:

- 类名是什么？
- 它是在哪里定义的？
- 它支持什么操作？

对于书店程序来说,我们假定类名为Sales_item,头文件Sales_item.h中已经定义了这个类。

如前所见,为了使用标准库设施,我们必须包含相关的头文件。类似的,我们也需要使用头文件来访问为自己的应用程序所定义的类。习惯上,头文件根据其中定义的类的名字来命名。我们通常使用.h作为头文件的后缀,但也有一些程序员习惯.H、.hpp或.hxx。标准库头文件通常不带后缀。编译器一般不关心头文件名的形式,但有的IDE对此有特定要求。

#### 1.5.1 Sales_item类

Sales_item类的作用是表示一本书的总销售额、售出册数和平均售价。我们现在不关心这些数据如何存储、如何计算。为了使用一个类,我们不必关心它是如何实现的,只需知道类对象可以执行什么操作。

每个类实际上都定义了一个新的类型,其类型名就是类名。因此,我们的Sales_item类定义了一个名为Sales item的类型。与内置类型一样,我们可以定义类类型的变量。当我们写下如下语句

```cpp
Sales item item;
```

是想表达item是一个Sales_item类型的对象。我们通常将“一个Sales_item类型的对象”简单说成“一个Sales_item对象”,或更简单的“一个Sales_item"。

除了可以定义Sales_item类型的变量之外,我们还可以:

- 调用一个名为isbn的函数从一个Sales_item对象中提取ISBN书号。
- 用输入运算符(>>)和输出运算符(<<)读、写Sales_item类型的对象。
- 用赋值运算符(=)将一个Sales_item对象的值赋予另一个Sales_item对象。
- 用加法运算符(+)将两个Sales_item对象相加。两个对象必须表示同一本书(相同的ISBN)。加法结果是一个新的Sales_item对象,其ISBN与两个运算对象相同,而其总销售额和售出册数则是两个运算对象的对应值之和。
- 使用复合赋值运算符(+=)将一个Sales_item对象加到另一个对象上。

>**关键概念:类定义了行为**
>当你读这些程序时,一件要牢记的重要事情是,类Sales_item的作者定义了类对象可以执行的所有动作。即,Sales_item类定义了创建一个Sales_item对象时会发生什么事情,以及对Sales_item对象进行赋值、加法或输入输出运算时会发生什么事情。
>一般而言,类的作者决定了类类型对象上可以使用的所有操作。当前,我们所知道的可以在Sales_item对象上执行的全部操作就是本节所列出的那些操作。

##### 读写Sales_item

既然已经知道可以对Sales_item对象执行哪些操作,我们现在就可以编写使用类的程序了。例如,下面的程序从标准输入读入数据,存入一个Sales_item对象中,然后将Sales_item的内容写回到标准输出:

```cpp
#include <iostream>
#include"Sales item.h"
int main()
{
Sales item book;
//读入ISBN号、售出的册数以及销售价格
std::cin >> book;
//写入ISBN、售出的册数、总销售额和平均价格
std::cout << book << std::endl;
return 0;
}
```

如果输入:

`0-201-70353-X 4 24.99`

则输出为:

`0-201-70353-X 4 99.96 24.99`

输入表示我们以每本24.99美元的价格售出了4册书,而输出告诉我们总售出册数为4,总销售额为99.96美元,而每册书的平均销售价格为24.99美元。

此程序以两个#include指令开始,其中一个使用了新的形式。包含来自标准库的头文件时,也应该用尖括号(<>)包围头文件名。对于不属于标准库的头文件,则用双引号("")包围。

在main中我们定义了一个名为book的对象,用来保存从标准输入读取出的数据。下一条语句读取数据存入对象中,第三条语句将对象打印到标准输出上并打印一个endl。

##### Sales_item对象的加法

下面是一个更有意思的例子,将两个Sales_item对象相加:

```cpp
#include <iostream>
#include"Sales_item.h"
int main()
{
Sales_item iteml,item2;
std::cin >> iteml >> item2;//读取一对交易记录
std::cout << iteml + item2 << std::endl;//打印它们的和
return 0;
}
```

如果输入如下内容:

`0-201-78345-x 3 20.000-201-78345-X 2 25.00`

则输出为:

`0-201-78345-X 5 110 22`

此程序开始包含了Sales_item和iostream两个头文件。然后定义了两个Sales_item对象来保存销售记录。我们从标准输入读取数据,存入两个对象之中。输出表达式完成加法运算并打印结果。

值得注意的是,此程序看起来与第5页的程序非常相似:读取两个输入数据并输出它们的和。造成如此相似的原因是,我们只不过将运算对象从两个整数变为两个Sales_item而已,但读取与打印和的运算方式没有发生任何变化。两个程序的另一个不同之处是,“和”的概念是完全不一样的。对于int,我们计算传统意义上的和--两个数值的算术加法结果。对于Sales_item对象,我们用了一个全新的“和”的概念一两个Sales_item对象的成员对应相加的结果。

>**使用文件重定向**
>当你测试程序时,反复从键盘敲入这些销售记录作为程序的输入,是非常乏味的。大多数操作系统支持文件重定向,这种机制允许我们将标准输入和标准输出与命名文件关联起来:
>
>`$ addI tems <infile >outfile`
>
>假定$是操作系统提示符,我们的加法程序已经编译为名为addItems.exe的可执行文件(在UNIX中是addItems),则上述命令会从一个名为infile的文件读取销售记录,并将输出结果写入到一个名为outfile的文件中,两个文件都位于当前目录中。

```cpp
#include <iostream>
#include "Sales_item.h"
using namespace std;
int main()
{
    Sales_item book1; //声明变量,并调用无参数构造函数
    //读入ISBN号,售出的册数以及销售价格
    cin >> book1;
    Sales_item book2 = Sales_item(); //调用无参构造函数
    //读入ISBN号,售出的册数以及销售价格
    cin >> book2;
    Sales_item book3("0-201-70353-X");       //调用一个参数构造函数
    Sales_item book4("0-201-70353-X", 2);    //调用二个参数构造函数
    Sales_item book5("0-201-70353-X", 2, 3); //调用三个参数构造函数
    Sales_item book6 = Sales_item(cin);       //读入ISBN号,售出的册数以及销售价格
    Sales_item book7();                      //声明函数,而不是调用无参构造函数
    //写出ISBN号,售出的册数、总销售额以及平均价格
    cout << book6 + book1 + book2 + book3 + book4 + book5 + book7() << endl;
    return 0;
}
Sales_item book7()
{
    Sales_item book;
    cin >> book;
    return book;
}
```

```cpp
//Sales_item.h
#ifndef Sales_item_H
#define Sales_item_H
#include <iostream>
#include <string>
using namespace std;
class Sales_item
{
private:                //私有数据成员
    string isbn;        //书的ISBN号
    unsigned unitsSold; //售出数量(本)
    double revenue;     //销售总价
public:                 //外部接口
                        //带默认值的构造函数,相当于4次重载:无参数,1参数,2参数,3参数
    Sales_item(string isbn = "", unsigned unitsSold = 0, double price = 0.0)
        : isbn(isbn), unitsSold(unitsSold)
    {
        revenue = price * unitsSold;
    }
    Sales_item(istream &is) { is >> *this; }                             //重载构造函数,用构造函数读入输入流
    Sales_item &operator+=(const Sales_item &s);                          //重载+=运算符
    friend istream &operator>>(istream &in, Sales_item &s);              //用友元函数重载>>运算符
    friend ostream &operator<<(ostream &is, const Sales_item &s);        //用友元函数重载<<运算符
    friend bool operator==(const Sales_item &lhs, const Sales_item &rhs); //友元函数可以访问私有数据成员
    double avgPrice() const                                             //求平均售价
    {
        if (unitsSold) //如果数量不为0,返回平均值
            return revenue / unitsSold;
        else //如果数量为0,返回0.0
            return 0.0;
    }
    bool sameIsbn(const Sales_item &s) //比较ISBN是否相等
    {
        return isbn == s.isbn;
    }
};
Sales_item operator+(const Sales_item &lhs, const Sales_item &rhs); //声明重载+运算符
istream &operator>>(istream &in, Sales_item &s)                   //实现重载>>运算符,返回左值,返回类型使用引用
{
    double price = 0;                     //定义单价
    in >> s.isbn >> s.unitsSold >> price; //输入流ISBN,数量,单价
    if (in)                               //如果输入流有效,计算总价
        s.revenue = s.unitsSold * price;
    else //否则,将无参数构造函数赋值给s
        s = Sales_item();
    return in; //返回左值
}
ostream &operator<<(ostream &is, const Sales_item &s) //实现重载<<运算符,返回左值,返回类型使用引用
{
    is << s.isbn << "\t" << s.unitsSold << "\t" << s.revenue << "\t" << s.avgPrice(); //输出几个值
    return is;                                                                        //返回左值
}
bool operator==(const Sales_item &lhs, const Sales_item &rhs) //声明并实现重载==运算符
{                                                           //全等为真,否则为假
    return lhs.unitsSold == rhs.unitsSold && lhs.isbn == rhs.isbn && lhs.revenue == rhs.revenue;
}
bool operator!=(const Sales_item &lhs, const Sales_item &rhs) //声明并实现重载!=运算符
{
    return !(lhs == rhs); //利用重载的==运算符
}
Sales_item &Sales_item::operator+=(const Sales_item &s) //实现重载+=运算符
{
    unitsSold += s.unitsSold;
    revenue += s.revenue;
    return *this; //返回左值
}
Sales_item operator+(const Sales_item &lhs, const Sales_item &rhs) //实现重载+运算符
{
    Sales_item ret(lhs); //利用构造函数创建对象
    return ret += rhs;  //调用重载的+=运算符
}
#endif
```

#### 1.5.2 初识成员函数

将两个Sales_item对象相加的程序首先应该检查两个对象是否具有相同的ISBN。方法如下:

```cpp
#include <iostream>
#include"Sales item.h"
int main()
{
    Sales item iteml,item2;
    std::cin >> iteml >> item2;
    //首先检查iteml和item2是否表示相同的书
    if(iteml.isbn()== item2.isbn()){
        std::cout << iteml + item2 << std::endl;
        return 0;//表示成功
    }else {
    std::cerr <<"Data must refer to same ISBN"
              << std::endl;
    return-1;//表示失败
    }
}
```

此程序与上一版本的差别是if语句及其else分支。即使不了解这个if语句的检测条件,我们也很容易理解这个程序在干什么。如果条件成立,如上一版本一样,程序打印计算结果,并返回0,表明成功。如果条件失败,我们执行跟在else之后的语句块,打印一条错误信息,并返回一个错误标识。

##### 什么是成员函数？

这个if语句的检测条件

```cpp
iteml.isbn() == item2.isbn()
```

调用名为isbn的成员函数(member function)。成员函数是定义为类的一部分的函数，有时也被称为方法(method)。

我们通常以一个类对象的名义来调用成员函数。例如，上面相等表达式左侧运算对象的第一部分

```cpp
iteml.isbn()
```

使用点运算符(.)来表达我们需要“名为item1的对象的isbn成员”。点运算符只能用于类类型的对象。其左侧运算对象必须是一个类类型的对象，右侧运算对象必须是该类型的一个成员名，运算结果为右侧运算对象指定的成员。

当用点运算符访问一个成员函数时，通常我们是想(效果也确实是)调用该函数。我们使用调用运算符(())来调用一个函数。调用运算符是一对圆括号，里面放置实参(argument)列表(可能为空)。成员函数isbn并不接受参数。因此

```cpp
iteml.isbn()
```

调用名为item1的对象的成员函数isbn，此函数返回item1中保存的ISBN书号。

在这个if条件中，相等运算符的右侧运算对象也是这样执行的--它返回保存在item2中的ISBN书号。如果ISBN相同，条件为真，否则为假。

```c++
#include <iostream>
#include "Sales_item.h"
using namespace std;
int main()
{
    Sales_item book1, book2; //声明变量,并调用无参数构造函数
    //读入ISBN号,售出的册数以及销售价格
    cin >> book1 >> book2;
    //检查是否是相同书籍
    if (book1.sameIsbn(book2)) //调用samIsbn函数
    {
        cout << book1 + book2 << endl;
        return 0; //表示成功
    }
    else
    {
        cerr << "Data must refer to same ISBN" << endl;
        return -1; //表示失败
    }
}
```

### 1.6 书店程序

现在我们已经准备好完成书店程序了。我们需要从一个文件中读取销售记录，生成每本书的销售报告，显示售出册数、总销售额和平均售价。我们假定每个ISBN书号的所有销售记录在文件中是聚在一起保存的。

我们的程序会将每个ISBN的所有数据合并起来，存入名为total的变量中。我们使用另一个名为trans的变量保存读取的每条销售记录。如果trans和total指向相同的ISBN，我们会更新total的值。否则，我们会打印total的值，并将其重置为刚刚读取的数据（trans）：

```cpp
#include <iostream>
#include "Sales_item.h"
using namespace std;
int main()
{
    Sales_item total; //保存下一条交易记录点变量
    //读入第一条交易记录,并确保有数据可以处理
    if (cin >> total)
    {
        Sales_item trans; //保存和的变量
        //读入并处理剩余交易记录
        while (cin >> trans)
        {
            //如果我们仍在处理相同的书
            if (total.sameIsbn(trans))
                total += trans; //更新总销售额
            else
            {
                //打印前一本书的结果
                cout << total << endl;
                total = trans; //total现在表示下一本书的销售额
            }
        }
        cout << total << endl; //打印最后一本书的结果
    }
    else
    {
        //没有输入！警告读者
        cerr << "No data?!" << endl;
        return -1; //表示失败
    }
    return 0;
}
```

这是到目前为止我们看到的最复杂的程序了，但它所使用的都是我们已经见过的语言特性。

与往常一样，首先包含要使用的头文件：来自标准库的iostream和自己定义的Sales_item.h。在main中，我们定义了一个名为total的变量，用来保存一个给定的ISBN的数据之和。我们首先读取第一条销售记录，存入total中，并检测这次读取操作是否成功。如果读取失败，则意味着没有任何销售记录，于是直接跳到最外层的else分支，打印一条警告信息，告诉用户没有输入。

假定已经成功读取了一条销售记录，我们继续执行最外层if之后的语句块。这个语句块首先定义一个名为trans的对象，它保存读取的销售记录。接下来的while语句将读取剩下的所有销售记录。与我们之前的程序一样，while条件是一个从标准输入读取值的操作。在本例中，我们读取一个Sales_item对象，存入trans中。只要读取成功，就执行while循环体。

while的循环体是一个单个的if语句，它检查ISBN是否相等。如果相等，使用复合赋值运算符将trans加到total中。如果ISBN不等，我们打印保存在total中的值，并将其重置为trans的值。在执行完if语句后，返回到while的循环条件，读取下一条销售记录，如此反复，直至所有销售记录都处理完。

当while语句终止时，total保存着文件中最后一个ISBN的数据。我们在语句块的最后一条语句中打印这最后一个ISBN的total值，至此最外层if语句就结束了

### 术语表

- `参数(实参,argument`)向函数传递的值。赋值(assignment)抹去一个对象的当前值,用一个新值取代之。
- `程序块(block)`零条或多条语句的序列,用花括号包围。
- `缓冲区(buffer)`一个存储区域,用于保存数据。IO设施通常将输入(或输出)数据保存在一个缓冲区中,读写缓冲区的动作与程序中的动作是无关的。我们可以显式地刷新输出缓冲,以便强制将缓冲区中的数据写入输出设备。默认情况下,读cin会刷新cout;程序非正常终止时也会刷新cout。
- `内置类型(built-in type)`由语言定义的类型,如int。
- `Cerr`一个ostream对象,关联到标准错误,通常写入到与标准输出相同的设备。默认情况下,写到cerr的数据是不缓冲的。cerr通常用于输出错误信息或其他不属于程序正常逻辑的输出内容。
- `字符串字面值常量(character string literal)`术语 string literal的另一种叫法。
- `cin`一个istream对象,用来从标准输入读取数据。
- `类(class)`一种用于定义自己的数据结构及其相关操作的机制。类是C++中最基本的特性之一。标准库类型中,如istream和ostream都是类。
- `类类型(class type`)类定义的类型。类名即为类型名。
- `clog`一个ostream对象,关联到标准错误。默认情况下,写到clog的数据是被缓冲的。c1og通常用于报告程序的执行信息,存入一个日志文件中。
- `注释(comment)`被编译器忽略的程序文本。C++有两种类型的注释:单行注释和界定符对注释。单行注释以//开始,从//
到行尾的所有内容都是注释。界定符对注释以/\*开始,其后的所有内容都是注释,直至遇到\*/为止。
- `条件(condition)`求值结果为真或假的表达式。通常用值0表示假,用非零值表示真。
- `cout`一个 ostream 对象,用于将数据写入标准输出。通常用于程序的正常输出内容。
- `花括号(curly brace)`花括号用于划定程序块边界。左花括号({)为程序块开始,右花括号(})为结束。
- `数据结构(data structure)`数据及其上所允许的操作的一种逻辑组合。
- `编辑-编译-调试(edit-compile-debug)`使程序能正确执行的开发过程。
- `文件结束符(end-of-file)`系统特定的标识,指出文件中无更多数据了。
- `表达式(expression)`最小的计算单元。一个表达式包含一个或多个运算对象,通常还包含一个或多个运算符。表达式求值会产生一个结果。例如,假设i和j是int对象,则i+j是一个表达式,它产生两个int值的和。
- `for 语句(for statement)`迭代语句,提供重复执行能力。通常用来将一个计算反复执行指定次数。
- `函数(function`)具名的计算单元。
- `函数体(function body`)语句块,定义了函数所执行的动作。
- `函数名(function name)`函数为人所知的名字,也用来进行函数调用。
- `头文件(header)`使类或其他名字的定义可被多个程序使用的一种机制。程序通过
- `#include`指令使用头文件。
- `if语句(if statement)`根据一个特定条件的值进行条件执行的语句。如果条件为真,执行if语句体。否则,执行else语句体(如果存在的话)。
- `初始化(initialize)`在一个对象创建的时候赋予它一个值。
- `iostream`头文件,提供了面向流的输入输出的标准库类型。
- `istream`提供了面向流的输入的库类型。
- `库类型(library type)`标准库定义的类型,如istream。
- `main`操作系统执行一个C++程序时所调用的函数。每个程序必须有且只有一个命名为main的函数。
- `操纵符(manipulator)`对象,如std:endl,在读写流的时候用来“操纵”流本身。
- `成员函数(member function)`类定义的操作。通常通过调用成员函数来操作特定对方法(method)成员函数的同义术语。
- `命名空间(namespace)`将库定义的名字放在一个单一位置的机制。命名空间可以帮助避免不经意的名字冲突。C++标准库定义的名字在命名空间std中。
- `ostream`标准库类型,提供面向流的输出。
- `形参列表(parameter list)`函数定义的一部分,指出调用函数时可以使用什么样的实参,可能为空列表。
- `返回类型(return type)`函数返回值的类型。
- `源文件(source file)`包含C++程序的文件。标准错误(standard error)输出流,用于报告错误。标准输出和标准错误通常关联到程序执行所在的窗口。
- `标准输入(standard input`)输入流,通常与程序执行所在窗口相关联。
- `标准库(standard library)`一个类型和函数的集合,每个C+编译器都必须支持。标准库提供了支持I0操作的类型。C++程序员倾向于用“库”指代整个标准库,还倾向于用库类型表示标准库的特定部分,例如用“iostream库”表示标准库中定义10类的部分。
- `标准输出(standard output)`输出流,通常与程序执行所在窗口相关联。
- `语句(statement)`程序的一部分,指定了当程序执行时进行什么动作。一个表达式接一个分号就是一条语句;其他类型的语句包括语句块、if语句、for 语句和while语句,所有这些语句内都包含其他语句。
- `std`标准库所使用的命名空间。std::cout表示我们要使用定义在命名空间std中的名字cout。
- `字符串常量(string literal)`零或多个字符组成的序列,用双引号包围("a string literal")。
- `未初始化的变量(uninitialized variable)`未赋予初值的变量。类类型的变量如果未指定初值,则按类定义指定的方式进行初始化。定义在函数内部的内置类型变量默认是不初始化的,除非有显式的初始化语句。试图使用一个未初始化变量的值是错误的。未初始化变量是bug的常见成因。
- `变量(variable)`具名对象。
- `while 语句(while statement)`迭代语句,提供重复执行直至一个特定条件为假的机制。循环体会执行零次或多次,依赖于循环条件求值结果。
- `()运算符(()operator)`调用运算符。跟随在函数名之后的一对括号“0”,起到调用函数的效果。传递给函数的实参放置在括号内。
- `++运算符(++operator)`递增运算符。将运算对象的值加1,++i等价于i=i+1。
- `+=运算符(+=operator)`复合赋值运算符,将右侧运算对象加到左侧运算对象上;a+=b等价于a=a+b。
- `.运算符(.operator)`点运算符。左侧运算对象必须是一个类类型对象,右侧运算对象必须是此对象的一个成员的名字。运算结果即为该对象的这个成员。
- `:运算符(:operator)`作用域运算符。其用处之一是访问命名空间中的名字。例如,std:cout 表示命名空间std中的名字cout。
- `=运算符(=operator)`将右侧运算对象的值赋予左侧运算对象所表示的对象。
- `-运算符(-operator)`递减运算符。将运算对象的值减1,--i等价于i=i-1。
- `<<运算符(<<operator)`输出运算符。将右侧运算对象的值写到左侧运算对象表示的输出流:cout<<"hi"表示将hi写到标准输出。输出运算符可以连接:cout<<"hi"<<"bye"表示将输出hibye。
- `>>运算符(>>operator)`输入运算符。从左侧运算对象所指定的输入流读取数据,存入右侧运算对象中:cin>>i表示从标准输入读取下一个值,存入i中。输入运算符可以连接:cin>>i>>j表示先读取一个值存入i,再读取一个值存入j。
- `#include`头文件包含指令,使头文件中代码可被程序使用。
- `==运算符(==operator)`相等运算符。检测左侧运算对象是否等于右侧运算对象。
- `!=运算符(!=operator)`不等运算符。检测左侧运算对象是否不等于右侧运算对象。
- `<=运算符(<=operator)`小于等于运算符。检测左侧运算对象是否小于等于右侧运算对象。
- `<运算符(<operator)`小于运算符。检测左侧运算对象是否小于右侧运算对象。
- `>=运算符(>=operator)`大于等于运算符。检测左侧运算对象是否大于等于右侧运算对象。
- `>运算符(>operator)`大于运算符。检测左侧运算对象是否大于右侧运算对象。
